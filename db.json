{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/aniqueue-result.jpg","path":"images/aniqueue-result.jpg","modified":1,"renderable":0},{"_id":"source/images/douglas-crockford.jpg","path":"images/douglas-crockford.jpg","modified":1,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":1,"renderable":0},{"_id":"source/images/nicholas-zakas.jpg","path":"images/nicholas-zakas.jpg","modified":1,"renderable":0},{"_id":"source/images/practice-1-result.png","path":"images/practice-1-result.png","modified":1,"renderable":0},{"_id":"source/images/profile-1.png","path":"images/profile-1.png","modified":1,"renderable":0},{"_id":"themes/april/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/april/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/april/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/april/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/april/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/april/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/april/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1492788366000},{"_id":"themes/april/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1491964013000},{"_id":"themes/april/README.md","hash":"ca1e11f5bc6d68a96c188b3f9f7ed81f64a4ffac","modified":1491967384000},{"_id":"themes/april/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1491964013000},{"_id":"themes/april/_config.yml","hash":"2a311a3bd71ac4d14248056f1590006296462426","modified":1495618672000},{"_id":"source/_drafts/like-me-2.md","hash":"b73c437d84934b8752a7fb7a052b0f21b153396e","modified":1493132442000},{"_id":"source/_posts/challenge-portfolio-page.md","hash":"08dbff17fb86072e1e02ea119fff50625d9e933b","modified":1492787974000},{"_id":"source/_posts/coin.md","hash":"0ed0e9b3c5ed093a52b35bdf7294a06cc8128dd2","modified":1492787974000},{"_id":"source/_posts/css-color-hex-code-and-rgb.md","hash":"26c33ddfb91289f97afc6e5ca05364af58cd8b49","modified":1492787974000},{"_id":"source/_posts/css-style-override.md","hash":"ce54d4facc7c732432ac7ec66022be40e0fa3041","modified":1492787974000},{"_id":"source/_posts/daily-commit-today-i-learned.md","hash":"fd4a054f653a2387a3b7dd5ffb744a2f07026a27","modified":1492787974000},{"_id":"source/_posts/fork-execlp-wait.md","hash":"233db875038999a654fd52156a4422e72f0fe64f","modified":1492787974000},{"_id":"source/_posts/introduction-to-blog.md","hash":"7f975107d16b2caad7ddc82fd311c92a702e190c","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-1.md","hash":"cbac81be97fffcf10d2ed40c8851c91745a7baf1","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-2.md","hash":"e38b79ef30d6ca26379bf31300e80fd6278453dd","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-3.md","hash":"0d07a5282f64c26890253717a6514379eadf38be","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-4.md","hash":"b18dcd4e32dbe21ec98ac3bc45c92c72b2696754","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-5.md","hash":"f031bfde6c6e7ef3a28a3782b816b88bd45359d2","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-6.md","hash":"2acdfa77b42d6ca3c6dd5d8774f7c98909d68d26","modified":1492787974000},{"_id":"source/_posts/javascript-daily-function-7.md","hash":"6ae4bdde5876e9de014da560be2d5b867dd85e28","modified":1493215812000},{"_id":"source/_posts/javascript-daily-function-8.md","hash":"f3a6ef1027c30a455515a7fa7288ba791c8f400e","modified":1493216662000},{"_id":"source/_posts/javascript-daily-function.md","hash":"ca7c0bd7d49053e06be24afd246fb7abe86b9822","modified":1492787974000},{"_id":"source/_posts/javascript-intro-1.md","hash":"9a099ba40e45bcae18d561461933284fdc1cdb28","modified":1492787974000},{"_id":"source/_posts/javascript-keywords.md","hash":"46cfb9b9f885bb0b7237a792316c3a093ccad996","modified":1492787974000},{"_id":"source/_posts/javascript-prototype.md","hash":"529d9a7fc1759acc6e96f4b23c33efe79fd21b3a","modified":1492787974000},{"_id":"source/_posts/javasrcipt-intro-2.md","hash":"e6ef174af9436b76781259228b30ccd8070dd607","modified":1492787974000},{"_id":"source/_posts/learn-about-mean-stack.md","hash":"ddf57dbf442665e41849716acf32252d07a9c01c","modified":1492787974000},{"_id":"source/_posts/like-me-1.md","hash":"12048298c2d2f14dbb762b5f5afc25bf811583a6","modified":1492787974000},{"_id":"source/_posts/practice-animal-shelter.md","hash":"e6f6b42ae2e24029d5207f695e1f4612f20b97d9","modified":1492787974000},{"_id":"source/_posts/practice-min-stack.md","hash":"6580a48c736339efd8c6e3c8bc7a242f4e699c4d","modified":1492787974000},{"_id":"source/_posts/prato-1.md","hash":"17152d0cdbbdb286400289c2c234a62ecad8426a","modified":1492787974000},{"_id":"source/_posts/prato-2.md","hash":"a251cf147d765c768834d26c10b2b362380dbf60","modified":1492787974000},{"_id":"source/_posts/project-tribute-page.md","hash":"6e81bd69f908b57631e7acddbb4e1e7a6e2d6246","modified":1492787974000},{"_id":"source/about/index.md","hash":"e8fd7ec992a84552317e7f764da2d3fda9255191","modified":1492787974000},{"_id":"source/images/aniqueue-result.jpg","hash":"badb9725b4fc9f26725ddba7e580fff8becbf391","modified":1492787974000},{"_id":"source/images/douglas-crockford.jpg","hash":"535cb26bd4d3cf60c9599ff5e317f048b8a52f9d","modified":1492787974000},{"_id":"source/images/logo.png","hash":"2316f51b5a7dee1339c289b8d88caf90f18304b5","modified":1492787974000},{"_id":"source/images/nicholas-zakas.jpg","hash":"6664a2f5939ae1ccfc37c972c2d6c49a892b4c78","modified":1492787974000},{"_id":"source/images/practice-1-result.png","hash":"0ace303eec00b434839c03ade29760ce8b61b52d","modified":1492787974000},{"_id":"source/images/profile-1.png","hash":"75a65bf9f9de1791cd0fa74aa7befe8b0d16f70e","modified":1492787974000},{"_id":"themes/april/layout/about.ejs","hash":"455b558cc8985f31f077483b6d02af80b4321fe5","modified":1491998222000},{"_id":"themes/april/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1491998108000},{"_id":"themes/april/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1491964013000},{"_id":"themes/april/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1491964013000},{"_id":"themes/april/layout/layout.ejs","hash":"34d2c8b54014f24facfa0869cab2e34164e50d3d","modified":1491986926000},{"_id":"themes/april/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491964013000},{"_id":"themes/april/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491964013000},{"_id":"themes/april/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1491964013000},{"_id":"themes/april/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1491964013000},{"_id":"themes/april/source/.DS_Store","hash":"3037d5331d92d3f549f33102664cadfff9459707","modified":1491978282000},{"_id":"themes/april/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1491964013000},{"_id":"themes/april/languages/ko.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1491966049000},{"_id":"themes/april/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1491964013000},{"_id":"themes/april/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1491964013000},{"_id":"themes/april/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1491964013000},{"_id":"themes/april/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1491964013000},{"_id":"themes/april/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1491964013000},{"_id":"themes/april/layout/_partial/about.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1491964013000},{"_id":"themes/april/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1491964013000},{"_id":"themes/april/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1491964013000},{"_id":"themes/april/layout/_partial/archive.ejs","hash":"c29b4b1c2a97dc78f183f0c6fefcd90b7db7f1e1","modified":1492090511000},{"_id":"themes/april/layout/_partial/article.ejs","hash":"08fbb8ff249d4f07eb7a8ca36bc44e491a3548ba","modified":1492091270000},{"_id":"themes/april/layout/_partial/footer.ejs","hash":"c6a757a53118a0d5e06e11073122c7fa18836136","modified":1491978994000},{"_id":"themes/april/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1491964013000},{"_id":"themes/april/layout/_partial/head.ejs","hash":"edf337d1559f2a4591f70cc6f342ecbd16fcb9b8","modified":1491997228000},{"_id":"themes/april/layout/_partial/header.ejs","hash":"7f3872caa968e19a863cff514ce00a17c0b587b6","modified":1493216856000},{"_id":"themes/april/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1491964013000},{"_id":"themes/april/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1491964013000},{"_id":"themes/april/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1491964013000},{"_id":"themes/april/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1491964013000},{"_id":"themes/april/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1491964013000},{"_id":"themes/april/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1491964013000},{"_id":"themes/april/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1491964013000},{"_id":"themes/april/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1491964013000},{"_id":"themes/april/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1491964013000},{"_id":"themes/april/source/css/style.styl","hash":"83f86df3061cae2be486b1ed1af37a17487f76b0","modified":1491987832000},{"_id":"themes/april/source/css/_variables.styl","hash":"559a411b5d59cb22e7982ad76c760240975a4910","modified":1491985550000},{"_id":"themes/april/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1491964013000},{"_id":"themes/april/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1491964013000},{"_id":"themes/april/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1491964013000},{"_id":"themes/april/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1491964013000},{"_id":"themes/april/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1491964013000},{"_id":"themes/april/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1491964013000},{"_id":"themes/april/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1491964013000},{"_id":"themes/april/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1491964013000},{"_id":"themes/april/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1491964013000},{"_id":"themes/april/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1491964013000},{"_id":"themes/april/source/css/_partial/comment.styl","hash":"249dc37403de5f60b5b0da860e0eb8942546def5","modified":1491983374000},{"_id":"themes/april/source/css/_partial/archive.styl","hash":"4fb6af381cf53cb1a5c54f3fd11a4863310455f5","modified":1491983374000},{"_id":"themes/april/source/css/_partial/footer.styl","hash":"851aa2d965533872943d130cb613b73930a02c60","modified":1491985766000},{"_id":"themes/april/source/css/_partial/article.styl","hash":"b656bd15af21c77bda2dec92177c0e6a847c101c","modified":1491983374000},{"_id":"themes/april/source/css/_partial/header.styl","hash":"bdb9d67b3ad35b0ed4dd990a72207581bf6fbb78","modified":1492090218000},{"_id":"themes/april/source/css/_partial/mobile.styl","hash":"e883e616fa54f3074d6b72b9dccddc01bd36be38","modified":1491987745000},{"_id":"themes/april/source/css/_partial/highlight.styl","hash":"8669d400aa45e8486023a4a759f78713c33800c5","modified":1491983374000},{"_id":"themes/april/source/css/_partial/sidebar-aside.styl","hash":"8f24c78e6c097eb89508d678b33d1fd835f3369a","modified":1491983374000},{"_id":"themes/april/source/css/_partial/sidebar.styl","hash":"bf69f78cfa7a03165e97941c1fe93ed987bbf45d","modified":1491983374000},{"_id":"themes/april/source/css/_partial/sidebar-bottom.styl","hash":"3edb2fbcefae464a7cfb584d3fcfb5c81ae81591","modified":1491983374000},{"_id":"themes/april/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1491964013000},{"_id":"themes/april/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1491964013000},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1491964013000},{"_id":"themes/april/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1491964013000},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1491964013000},{"_id":"themes/april/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1491964013000},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1491964013000},{"_id":"themes/april/source/css/images/favicon.ico","hash":"ffa7caa55751aa10dd72f4f552c8bab909bac97c","modified":1492089403000},{"_id":"themes/april/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1491964013000},{"_id":"themes/april/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1491964013000}],"Category":[{"name":"joeun.me","_id":"cj33ux1mx0002i3vgpa3xhugj"},{"name":"rabbylab(wordpress)","_id":"cj33ux1nu0007i3vgdke4ytjv"},{"name":"view of value","parent":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1od000ki3vgib5fig69"},{"name":"programming","parent":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1qa0014i3vgzagbx7wv"}],"Data":[],"Page":[{"title":"블로그 소개","date":"2017-04-13T13:38:55.000Z","_content":"안녕하세요. 개발자 하조은입니다.\n\n### 블로그는 왜 하는걸까?\n- 누군가는 블로그를 저장소(Archives)로 생각합니다. 단순한 기록이 모인 곳입니다.\n- 누군가는 블로그를 능력을 표현(자랑)하는 공간으로 생각합니다. 자신이 사용하는 기술을 소개하고 설명합니다. \n\n우선 저는 블로그를 단순한 기록을 위한 용도로 사용하고 싶지 않습니다. 그건 에버노트로 충분하니까요.\n한편으로 제게는 자랑할만한 능력은 없습니다. 기술을 사용하지만 아직은 누군가를 가르칠 수준은 아닙니다.\n\n때문에 저는 이 블로그를 제 **생각의 그릇**으로 사용할까합니다. 제가 공부하고 사용하는 기술과 일상에 대한 생각을 털어놓고 의견을 받고 함께 고민하는 장으로 사용하고 싶습니다. 조금은 조촐해 보이는 UI를 유지할지도 모르겠습니다. 주객이 전도되는 꼴을 면하고 싶기 때문입니다.\n제법 많은 시간동안 예쁜 그릇을 고르는 것에 에너지를 소모했습니다. 워드프레스, 브런치, 티스토리 등의 플랫폼을 기웃거렸던 이유도 예쁜 그릇을 찾기 위함이었습니다. 보기 좋은 음식이 먹기에도 좋다는 말처럼 예쁜 플랫폼에 담긴 글은 제 어설픈 생각을 제법 그럴듯하게 포장해 줄 것만 같았기 때문입니다.\n그런 생각을 접어두려고 합니다. 조금 어설프고 앞뒤가 맞지 않는다해도 가감없이 제 생각을 털어놓고 싶습니다. 요즘은 이런 목적을 위한 많은 채널이 있지만 저는 조금 더 전문적이고 딱딱한 이야기를 하기에 블로그가 적절하다고 생각했습니다. 굳이 블로그를 운영하는 이유입니다.\n\n### 어떤 이야기(주제)를 다룰까?\n\n한동안은 시리즈로 글을 풀어나가볼까 합니다. \n\n1. [오늘의 함수] 시리즈\n \n 첫 문장에서 어엿한 개발자인척 스스로를 소개했지만 사실 저는 아직 일을 시작한지 1년도 되지 않은 초보 개발자입니다. 때문에 제가 공부하는 개발(Software Development)에 관한 이야기를 많이 다룰 생각입니다. 그 첫번째 시리즈가 바로 오늘의 함수 시리즈입니다. 특이하게도 제가 일하는 회사에서는 함수형 프로그래밍을 합니다. 때문에 특이한 함수와 그 사용법을 소개하는 시리즈를 연재할까합니다. (사용하는 언어는 JavaScript입니다.)\n\n2. [나와 같다면] 시리즈\n \n ‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’ 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.","source":"about/index.md","raw":"---\ntitle: 블로그 소개\ndate: 2017-04-13 22:38:55\n---\n안녕하세요. 개발자 하조은입니다.\n\n### 블로그는 왜 하는걸까?\n- 누군가는 블로그를 저장소(Archives)로 생각합니다. 단순한 기록이 모인 곳입니다.\n- 누군가는 블로그를 능력을 표현(자랑)하는 공간으로 생각합니다. 자신이 사용하는 기술을 소개하고 설명합니다. \n\n우선 저는 블로그를 단순한 기록을 위한 용도로 사용하고 싶지 않습니다. 그건 에버노트로 충분하니까요.\n한편으로 제게는 자랑할만한 능력은 없습니다. 기술을 사용하지만 아직은 누군가를 가르칠 수준은 아닙니다.\n\n때문에 저는 이 블로그를 제 **생각의 그릇**으로 사용할까합니다. 제가 공부하고 사용하는 기술과 일상에 대한 생각을 털어놓고 의견을 받고 함께 고민하는 장으로 사용하고 싶습니다. 조금은 조촐해 보이는 UI를 유지할지도 모르겠습니다. 주객이 전도되는 꼴을 면하고 싶기 때문입니다.\n제법 많은 시간동안 예쁜 그릇을 고르는 것에 에너지를 소모했습니다. 워드프레스, 브런치, 티스토리 등의 플랫폼을 기웃거렸던 이유도 예쁜 그릇을 찾기 위함이었습니다. 보기 좋은 음식이 먹기에도 좋다는 말처럼 예쁜 플랫폼에 담긴 글은 제 어설픈 생각을 제법 그럴듯하게 포장해 줄 것만 같았기 때문입니다.\n그런 생각을 접어두려고 합니다. 조금 어설프고 앞뒤가 맞지 않는다해도 가감없이 제 생각을 털어놓고 싶습니다. 요즘은 이런 목적을 위한 많은 채널이 있지만 저는 조금 더 전문적이고 딱딱한 이야기를 하기에 블로그가 적절하다고 생각했습니다. 굳이 블로그를 운영하는 이유입니다.\n\n### 어떤 이야기(주제)를 다룰까?\n\n한동안은 시리즈로 글을 풀어나가볼까 합니다. \n\n1. [오늘의 함수] 시리즈\n \n 첫 문장에서 어엿한 개발자인척 스스로를 소개했지만 사실 저는 아직 일을 시작한지 1년도 되지 않은 초보 개발자입니다. 때문에 제가 공부하는 개발(Software Development)에 관한 이야기를 많이 다룰 생각입니다. 그 첫번째 시리즈가 바로 오늘의 함수 시리즈입니다. 특이하게도 제가 일하는 회사에서는 함수형 프로그래밍을 합니다. 때문에 특이한 함수와 그 사용법을 소개하는 시리즈를 연재할까합니다. (사용하는 언어는 JavaScript입니다.)\n\n2. [나와 같다면] 시리즈\n \n ‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’ 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.","updated":"2017-04-21T15:19:34.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj33ux1pq000yi3vg0z0zzvr0","content":"<p>안녕하세요. 개발자 하조은입니다.</p>\n<h3 id=\"블로그는-왜-하는걸까\"><a href=\"#블로그는-왜-하는걸까\" class=\"headerlink\" title=\"블로그는 왜 하는걸까?\"></a>블로그는 왜 하는걸까?</h3><ul>\n<li>누군가는 블로그를 저장소(Archives)로 생각합니다. 단순한 기록이 모인 곳입니다.</li>\n<li>누군가는 블로그를 능력을 표현(자랑)하는 공간으로 생각합니다. 자신이 사용하는 기술을 소개하고 설명합니다. </li>\n</ul>\n<p>우선 저는 블로그를 단순한 기록을 위한 용도로 사용하고 싶지 않습니다. 그건 에버노트로 충분하니까요.<br>한편으로 제게는 자랑할만한 능력은 없습니다. 기술을 사용하지만 아직은 누군가를 가르칠 수준은 아닙니다.</p>\n<p>때문에 저는 이 블로그를 제 <strong>생각의 그릇</strong>으로 사용할까합니다. 제가 공부하고 사용하는 기술과 일상에 대한 생각을 털어놓고 의견을 받고 함께 고민하는 장으로 사용하고 싶습니다. 조금은 조촐해 보이는 UI를 유지할지도 모르겠습니다. 주객이 전도되는 꼴을 면하고 싶기 때문입니다.<br>제법 많은 시간동안 예쁜 그릇을 고르는 것에 에너지를 소모했습니다. 워드프레스, 브런치, 티스토리 등의 플랫폼을 기웃거렸던 이유도 예쁜 그릇을 찾기 위함이었습니다. 보기 좋은 음식이 먹기에도 좋다는 말처럼 예쁜 플랫폼에 담긴 글은 제 어설픈 생각을 제법 그럴듯하게 포장해 줄 것만 같았기 때문입니다.<br>그런 생각을 접어두려고 합니다. 조금 어설프고 앞뒤가 맞지 않는다해도 가감없이 제 생각을 털어놓고 싶습니다. 요즘은 이런 목적을 위한 많은 채널이 있지만 저는 조금 더 전문적이고 딱딱한 이야기를 하기에 블로그가 적절하다고 생각했습니다. 굳이 블로그를 운영하는 이유입니다.</p>\n<h3 id=\"어떤-이야기-주제-를-다룰까\"><a href=\"#어떤-이야기-주제-를-다룰까\" class=\"headerlink\" title=\"어떤 이야기(주제)를 다룰까?\"></a>어떤 이야기(주제)를 다룰까?</h3><p>한동안은 시리즈로 글을 풀어나가볼까 합니다. </p>\n<ol>\n<li><p>[오늘의 함수] 시리즈</p>\n<p>첫 문장에서 어엿한 개발자인척 스스로를 소개했지만 사실 저는 아직 일을 시작한지 1년도 되지 않은 초보 개발자입니다. 때문에 제가 공부하는 개발(Software Development)에 관한 이야기를 많이 다룰 생각입니다. 그 첫번째 시리즈가 바로 오늘의 함수 시리즈입니다. 특이하게도 제가 일하는 회사에서는 함수형 프로그래밍을 합니다. 때문에 특이한 함수와 그 사용법을 소개하는 시리즈를 연재할까합니다. (사용하는 언어는 JavaScript입니다.)</p>\n</li>\n<li><p>[나와 같다면] 시리즈</p>\n<p>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’ 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>안녕하세요. 개발자 하조은입니다.</p>\n<h3 id=\"블로그는-왜-하는걸까\"><a href=\"#블로그는-왜-하는걸까\" class=\"headerlink\" title=\"블로그는 왜 하는걸까?\"></a>블로그는 왜 하는걸까?</h3><ul>\n<li>누군가는 블로그를 저장소(Archives)로 생각합니다. 단순한 기록이 모인 곳입니다.</li>\n<li>누군가는 블로그를 능력을 표현(자랑)하는 공간으로 생각합니다. 자신이 사용하는 기술을 소개하고 설명합니다. </li>\n</ul>\n<p>우선 저는 블로그를 단순한 기록을 위한 용도로 사용하고 싶지 않습니다. 그건 에버노트로 충분하니까요.<br>한편으로 제게는 자랑할만한 능력은 없습니다. 기술을 사용하지만 아직은 누군가를 가르칠 수준은 아닙니다.</p>\n<p>때문에 저는 이 블로그를 제 <strong>생각의 그릇</strong>으로 사용할까합니다. 제가 공부하고 사용하는 기술과 일상에 대한 생각을 털어놓고 의견을 받고 함께 고민하는 장으로 사용하고 싶습니다. 조금은 조촐해 보이는 UI를 유지할지도 모르겠습니다. 주객이 전도되는 꼴을 면하고 싶기 때문입니다.<br>제법 많은 시간동안 예쁜 그릇을 고르는 것에 에너지를 소모했습니다. 워드프레스, 브런치, 티스토리 등의 플랫폼을 기웃거렸던 이유도 예쁜 그릇을 찾기 위함이었습니다. 보기 좋은 음식이 먹기에도 좋다는 말처럼 예쁜 플랫폼에 담긴 글은 제 어설픈 생각을 제법 그럴듯하게 포장해 줄 것만 같았기 때문입니다.<br>그런 생각을 접어두려고 합니다. 조금 어설프고 앞뒤가 맞지 않는다해도 가감없이 제 생각을 털어놓고 싶습니다. 요즘은 이런 목적을 위한 많은 채널이 있지만 저는 조금 더 전문적이고 딱딱한 이야기를 하기에 블로그가 적절하다고 생각했습니다. 굳이 블로그를 운영하는 이유입니다.</p>\n<h3 id=\"어떤-이야기-주제-를-다룰까\"><a href=\"#어떤-이야기-주제-를-다룰까\" class=\"headerlink\" title=\"어떤 이야기(주제)를 다룰까?\"></a>어떤 이야기(주제)를 다룰까?</h3><p>한동안은 시리즈로 글을 풀어나가볼까 합니다. </p>\n<ol>\n<li><p>[오늘의 함수] 시리즈</p>\n<p>첫 문장에서 어엿한 개발자인척 스스로를 소개했지만 사실 저는 아직 일을 시작한지 1년도 되지 않은 초보 개발자입니다. 때문에 제가 공부하는 개발(Software Development)에 관한 이야기를 많이 다룰 생각입니다. 그 첫번째 시리즈가 바로 오늘의 함수 시리즈입니다. 특이하게도 제가 일하는 회사에서는 함수형 프로그래밍을 합니다. 때문에 특이한 함수와 그 사용법을 소개하는 시리즈를 연재할까합니다. (사용하는 언어는 JavaScript입니다.)</p>\n</li>\n<li><p>[나와 같다면] 시리즈</p>\n<p>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’ 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n</li>\n</ol>\n"}],"Post":[{"title":"[나와 같다면] 문과스러운 프로그래밍","date":"2017-04-14T13:45:08.000Z","_content":"##### [나와 같다면] 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n#### 나는 문과생이었다\n나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다. 언론을 전공했고 광고인이 되는 것을 꿈꿨다. \n\n대학 1년을 마치고 군대를 갔다 왔다. 내가 다니는 학교에선 광고를 배울 수 없다고 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 십분활용했다. 그렇게 전과범이되었다. 교양으로 들었던 'C 프로그래밍'을 들으며 처음 컴퓨터 언어를 만났을 때 그때 __프로그래핑은 문과스러운 점이 많다는 것__을 깨달았다.\n\n사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 무엇인가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. \n\n교양 수업을 듣기 전에 방학에 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. \n\n개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 '배열'이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라는 별명을 가지고 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.\n\n이 과정에서 몇가지 사실을 깨닫게 되었다. 학습 자체는 단어를 배워나가는 과정이라는 점. 특정 단어가 이 분야에서 어떤 의미를 지니는지를 배우고 이해하고 느끼는 과정이 학습이라는 점이다. 반복되는 학습으로 인해 그 단어가 체화되고 자연스럽게 그 단어를 올바른 방법으로 사용할 수 있도록 하는게 교육이라는 점이다. 그런 점에서 공대의 공부도 결국 단어를 익혀가는 과정임으로 그리 겁먹을 필요가 없다는 점을 이해하게 되었다. 무엇보다 중요한 사실은 컴퓨터 언어가 아주 많이 문과스럽다는 점을 깨달았다. \n\n#### 문과스러운 프로그래밍\n프로그래밍이 문과스럽다는 말은 프로그래밍이 글쓰기와 유사하다는 생각에서 나온 것이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. \n\n결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 __논리적으로__ 글 혹은 코드를 __작성하는 행위__라는 점에서 유사하다. \n\n\n\n\n문과스러운 프로그래밍\n첫째 깨달음에 대한 자세한 이야기는 이 글에 취지와 맞지 않으니 문과스러운 프로그래밍에 대해 조금만 더 이야기해보겠습니다. 당시에 문과에서 쭉 공부해 온 제가 프로그래밍이 문과스럽다고 느꼈던 것은 프로그래밍하는 과정에서 제가 걱정했던 수학적인 부분보다는 문법적이고 논리적인 과정이 더 자주 등장하는 것을 보았기 때문이었습니다. 특히나 조건문이라는 것이 자주 등장하는데 그냥 논리의 덩어리입니다. 조건문은 이렇게 작성합니다. 'if (a > b) { action() }' 이 코드의 의미는 '만약에 a가 b보다 크면, action하라'는 뜻입니다. 프로그래밍하며 작성하는 코드의 상당수가 이런 조건문에 의해 결정되고 구성됩니다. 이러한 조건문들이 나열되고 그 조건문에 의해 실행될 함수(function)들을 정의하는 과정이 프로그래밍입니다. 마치 글을 작성하는 것 같지 않나요? \n\n여기서 말하는 함수란 어떤 행동을 해라고 정의해둔 명령들의 집합이라고 생각하시면 됩니다. 조금 억지로 예를 들어보자면 지금 제 글의 조건문은 '만약 당신이 개발이 어려운 것이라고 생각한다면~'입니다. 그리고 이 글의 함수는 '그건 오해야. 생각보단 쉬워. 그러니 한번 배워봐!'인 겁니다. 이걸 만약에 프로그래밍한다면, 'if (programmingIsHard) { changeYourMind(); }' 이런 느낌일 겁니다. 그렇게 어렵지 않습니다. 어떠세요. 제법 문과스럽지 않나요?\n\n\n맺음\n이렇게 의외로 문과스럽고 생각보다 쉽고 재밌는 프로그래밍의 매력에 빠져서 저는 대학교 2학년 2학기에 컴퓨터 공학으로의 전과를 선택하게 됩니다. 그리고 대학을 졸업하고 지금은 웹 개발자로 일하고 있습니다. 정말 어쩌다 보니 개발자가 되어있습니다. 물론 아직 아주 많이 미숙한 수준의 개발자입니다. 스스로를 개발자라 부르기도 민망한 처지입니다. 하지만 앞으로 브런치에 글도 올리고 열심히 일하면서 성장하는 모습 보여드리겠습니다. 감사합니다. ","source":"_drafts/like-me-2.md","raw":"---\ntitle: '[나와 같다면] 문과스러운 프로그래밍'\ndate: 2017-04-14 22:45:08\ncategories:\n  - joeun.me\n  - view of value\ntags:\n  - opinion\n  - 나와같다면\n---\n##### [나와 같다면] 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n#### 나는 문과생이었다\n나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다. 언론을 전공했고 광고인이 되는 것을 꿈꿨다. \n\n대학 1년을 마치고 군대를 갔다 왔다. 내가 다니는 학교에선 광고를 배울 수 없다고 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 십분활용했다. 그렇게 전과범이되었다. 교양으로 들었던 'C 프로그래밍'을 들으며 처음 컴퓨터 언어를 만났을 때 그때 __프로그래핑은 문과스러운 점이 많다는 것__을 깨달았다.\n\n사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 무엇인가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. \n\n교양 수업을 듣기 전에 방학에 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. \n\n개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 '배열'이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라는 별명을 가지고 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.\n\n이 과정에서 몇가지 사실을 깨닫게 되었다. 학습 자체는 단어를 배워나가는 과정이라는 점. 특정 단어가 이 분야에서 어떤 의미를 지니는지를 배우고 이해하고 느끼는 과정이 학습이라는 점이다. 반복되는 학습으로 인해 그 단어가 체화되고 자연스럽게 그 단어를 올바른 방법으로 사용할 수 있도록 하는게 교육이라는 점이다. 그런 점에서 공대의 공부도 결국 단어를 익혀가는 과정임으로 그리 겁먹을 필요가 없다는 점을 이해하게 되었다. 무엇보다 중요한 사실은 컴퓨터 언어가 아주 많이 문과스럽다는 점을 깨달았다. \n\n#### 문과스러운 프로그래밍\n프로그래밍이 문과스럽다는 말은 프로그래밍이 글쓰기와 유사하다는 생각에서 나온 것이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. \n\n결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 __논리적으로__ 글 혹은 코드를 __작성하는 행위__라는 점에서 유사하다. \n\n\n\n\n문과스러운 프로그래밍\n첫째 깨달음에 대한 자세한 이야기는 이 글에 취지와 맞지 않으니 문과스러운 프로그래밍에 대해 조금만 더 이야기해보겠습니다. 당시에 문과에서 쭉 공부해 온 제가 프로그래밍이 문과스럽다고 느꼈던 것은 프로그래밍하는 과정에서 제가 걱정했던 수학적인 부분보다는 문법적이고 논리적인 과정이 더 자주 등장하는 것을 보았기 때문이었습니다. 특히나 조건문이라는 것이 자주 등장하는데 그냥 논리의 덩어리입니다. 조건문은 이렇게 작성합니다. 'if (a > b) { action() }' 이 코드의 의미는 '만약에 a가 b보다 크면, action하라'는 뜻입니다. 프로그래밍하며 작성하는 코드의 상당수가 이런 조건문에 의해 결정되고 구성됩니다. 이러한 조건문들이 나열되고 그 조건문에 의해 실행될 함수(function)들을 정의하는 과정이 프로그래밍입니다. 마치 글을 작성하는 것 같지 않나요? \n\n여기서 말하는 함수란 어떤 행동을 해라고 정의해둔 명령들의 집합이라고 생각하시면 됩니다. 조금 억지로 예를 들어보자면 지금 제 글의 조건문은 '만약 당신이 개발이 어려운 것이라고 생각한다면~'입니다. 그리고 이 글의 함수는 '그건 오해야. 생각보단 쉬워. 그러니 한번 배워봐!'인 겁니다. 이걸 만약에 프로그래밍한다면, 'if (programmingIsHard) { changeYourMind(); }' 이런 느낌일 겁니다. 그렇게 어렵지 않습니다. 어떠세요. 제법 문과스럽지 않나요?\n\n\n맺음\n이렇게 의외로 문과스럽고 생각보다 쉽고 재밌는 프로그래밍의 매력에 빠져서 저는 대학교 2학년 2학기에 컴퓨터 공학으로의 전과를 선택하게 됩니다. 그리고 대학을 졸업하고 지금은 웹 개발자로 일하고 있습니다. 정말 어쩌다 보니 개발자가 되어있습니다. 물론 아직 아주 많이 미숙한 수준의 개발자입니다. 스스로를 개발자라 부르기도 민망한 처지입니다. 하지만 앞으로 브런치에 글도 올리고 열심히 일하면서 성장하는 모습 보여드리겠습니다. 감사합니다. ","slug":"like-me-2","published":0,"updated":"2017-04-25T15:00:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1mn0000i3vgqy5pz9k2","content":"<h5 id=\"나와-같다면-시리즈-소개\"><a href=\"#나와-같다면-시리즈-소개\" class=\"headerlink\" title=\"[나와 같다면] 시리즈 소개\"></a>[나와 같다면] 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h4 id=\"나는-문과생이었다\"><a href=\"#나는-문과생이었다\" class=\"headerlink\" title=\"나는 문과생이었다\"></a>나는 문과생이었다</h4><p>나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다. 언론을 전공했고 광고인이 되는 것을 꿈꿨다. </p>\n<p>대학 1년을 마치고 군대를 갔다 왔다. 내가 다니는 학교에선 광고를 배울 수 없다고 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 십분활용했다. 그렇게 전과범이되었다. 교양으로 들었던 ‘C 프로그래밍’을 들으며 처음 컴퓨터 언어를 만났을 때 그때 <strong>프로그래핑은 문과스러운 점이 많다는 것</strong>을 깨달았다.</p>\n<p>사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 무엇인가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. </p>\n<p>교양 수업을 듣기 전에 방학에 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. </p>\n<p>개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 ‘배열’이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라는 별명을 가지고 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.</p>\n<p>이 과정에서 몇가지 사실을 깨닫게 되었다. 학습 자체는 단어를 배워나가는 과정이라는 점. 특정 단어가 이 분야에서 어떤 의미를 지니는지를 배우고 이해하고 느끼는 과정이 학습이라는 점이다. 반복되는 학습으로 인해 그 단어가 체화되고 자연스럽게 그 단어를 올바른 방법으로 사용할 수 있도록 하는게 교육이라는 점이다. 그런 점에서 공대의 공부도 결국 단어를 익혀가는 과정임으로 그리 겁먹을 필요가 없다는 점을 이해하게 되었다. 무엇보다 중요한 사실은 컴퓨터 언어가 아주 많이 문과스럽다는 점을 깨달았다. </p>\n<h4 id=\"문과스러운-프로그래밍\"><a href=\"#문과스러운-프로그래밍\" class=\"headerlink\" title=\"문과스러운 프로그래밍\"></a>문과스러운 프로그래밍</h4><p>프로그래밍이 문과스럽다는 말은 프로그래밍이 글쓰기와 유사하다는 생각에서 나온 것이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. </p>\n<p>결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 <strong>논리적으로</strong> 글 혹은 코드를 <strong>작성하는 행위</strong>라는 점에서 유사하다. </p>\n<p>문과스러운 프로그래밍<br>첫째 깨달음에 대한 자세한 이야기는 이 글에 취지와 맞지 않으니 문과스러운 프로그래밍에 대해 조금만 더 이야기해보겠습니다. 당시에 문과에서 쭉 공부해 온 제가 프로그래밍이 문과스럽다고 느꼈던 것은 프로그래밍하는 과정에서 제가 걱정했던 수학적인 부분보다는 문법적이고 논리적인 과정이 더 자주 등장하는 것을 보았기 때문이었습니다. 특히나 조건문이라는 것이 자주 등장하는데 그냥 논리의 덩어리입니다. 조건문은 이렇게 작성합니다. ‘if (a &gt; b) { action() }’ 이 코드의 의미는 ‘만약에 a가 b보다 크면, action하라’는 뜻입니다. 프로그래밍하며 작성하는 코드의 상당수가 이런 조건문에 의해 결정되고 구성됩니다. 이러한 조건문들이 나열되고 그 조건문에 의해 실행될 함수(function)들을 정의하는 과정이 프로그래밍입니다. 마치 글을 작성하는 것 같지 않나요? </p>\n<p>여기서 말하는 함수란 어떤 행동을 해라고 정의해둔 명령들의 집합이라고 생각하시면 됩니다. 조금 억지로 예를 들어보자면 지금 제 글의 조건문은 ‘만약 당신이 개발이 어려운 것이라고 생각한다면~’입니다. 그리고 이 글의 함수는 ‘그건 오해야. 생각보단 쉬워. 그러니 한번 배워봐!’인 겁니다. 이걸 만약에 프로그래밍한다면, ‘if (programmingIsHard) { changeYourMind(); }’ 이런 느낌일 겁니다. 그렇게 어렵지 않습니다. 어떠세요. 제법 문과스럽지 않나요?</p>\n<p>맺음<br>이렇게 의외로 문과스럽고 생각보다 쉽고 재밌는 프로그래밍의 매력에 빠져서 저는 대학교 2학년 2학기에 컴퓨터 공학으로의 전과를 선택하게 됩니다. 그리고 대학을 졸업하고 지금은 웹 개발자로 일하고 있습니다. 정말 어쩌다 보니 개발자가 되어있습니다. 물론 아직 아주 많이 미숙한 수준의 개발자입니다. 스스로를 개발자라 부르기도 민망한 처지입니다. 하지만 앞으로 브런치에 글도 올리고 열심히 일하면서 성장하는 모습 보여드리겠습니다. 감사합니다. </p>\n","excerpt":"","more":"<h5 id=\"나와-같다면-시리즈-소개\"><a href=\"#나와-같다면-시리즈-소개\" class=\"headerlink\" title=\"[나와 같다면] 시리즈 소개\"></a>[나와 같다면] 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h4 id=\"나는-문과생이었다\"><a href=\"#나는-문과생이었다\" class=\"headerlink\" title=\"나는 문과생이었다\"></a>나는 문과생이었다</h4><p>나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다. 언론을 전공했고 광고인이 되는 것을 꿈꿨다. </p>\n<p>대학 1년을 마치고 군대를 갔다 왔다. 내가 다니는 학교에선 광고를 배울 수 없다고 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 십분활용했다. 그렇게 전과범이되었다. 교양으로 들었던 ‘C 프로그래밍’을 들으며 처음 컴퓨터 언어를 만났을 때 그때 <strong>프로그래핑은 문과스러운 점이 많다는 것</strong>을 깨달았다.</p>\n<p>사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 무엇인가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. </p>\n<p>교양 수업을 듣기 전에 방학에 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. </p>\n<p>개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 ‘배열’이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라는 별명을 가지고 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.</p>\n<p>이 과정에서 몇가지 사실을 깨닫게 되었다. 학습 자체는 단어를 배워나가는 과정이라는 점. 특정 단어가 이 분야에서 어떤 의미를 지니는지를 배우고 이해하고 느끼는 과정이 학습이라는 점이다. 반복되는 학습으로 인해 그 단어가 체화되고 자연스럽게 그 단어를 올바른 방법으로 사용할 수 있도록 하는게 교육이라는 점이다. 그런 점에서 공대의 공부도 결국 단어를 익혀가는 과정임으로 그리 겁먹을 필요가 없다는 점을 이해하게 되었다. 무엇보다 중요한 사실은 컴퓨터 언어가 아주 많이 문과스럽다는 점을 깨달았다. </p>\n<h4 id=\"문과스러운-프로그래밍\"><a href=\"#문과스러운-프로그래밍\" class=\"headerlink\" title=\"문과스러운 프로그래밍\"></a>문과스러운 프로그래밍</h4><p>프로그래밍이 문과스럽다는 말은 프로그래밍이 글쓰기와 유사하다는 생각에서 나온 것이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. </p>\n<p>결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 <strong>논리적으로</strong> 글 혹은 코드를 <strong>작성하는 행위</strong>라는 점에서 유사하다. </p>\n<p>문과스러운 프로그래밍<br>첫째 깨달음에 대한 자세한 이야기는 이 글에 취지와 맞지 않으니 문과스러운 프로그래밍에 대해 조금만 더 이야기해보겠습니다. 당시에 문과에서 쭉 공부해 온 제가 프로그래밍이 문과스럽다고 느꼈던 것은 프로그래밍하는 과정에서 제가 걱정했던 수학적인 부분보다는 문법적이고 논리적인 과정이 더 자주 등장하는 것을 보았기 때문이었습니다. 특히나 조건문이라는 것이 자주 등장하는데 그냥 논리의 덩어리입니다. 조건문은 이렇게 작성합니다. ‘if (a &gt; b) { action() }’ 이 코드의 의미는 ‘만약에 a가 b보다 크면, action하라’는 뜻입니다. 프로그래밍하며 작성하는 코드의 상당수가 이런 조건문에 의해 결정되고 구성됩니다. 이러한 조건문들이 나열되고 그 조건문에 의해 실행될 함수(function)들을 정의하는 과정이 프로그래밍입니다. 마치 글을 작성하는 것 같지 않나요? </p>\n<p>여기서 말하는 함수란 어떤 행동을 해라고 정의해둔 명령들의 집합이라고 생각하시면 됩니다. 조금 억지로 예를 들어보자면 지금 제 글의 조건문은 ‘만약 당신이 개발이 어려운 것이라고 생각한다면~’입니다. 그리고 이 글의 함수는 ‘그건 오해야. 생각보단 쉬워. 그러니 한번 배워봐!’인 겁니다. 이걸 만약에 프로그래밍한다면, ‘if (programmingIsHard) { changeYourMind(); }’ 이런 느낌일 겁니다. 그렇게 어렵지 않습니다. 어떠세요. 제법 문과스럽지 않나요?</p>\n<p>맺음<br>이렇게 의외로 문과스럽고 생각보다 쉽고 재밌는 프로그래밍의 매력에 빠져서 저는 대학교 2학년 2학기에 컴퓨터 공학으로의 전과를 선택하게 됩니다. 그리고 대학을 졸업하고 지금은 웹 개발자로 일하고 있습니다. 정말 어쩌다 보니 개발자가 되어있습니다. 물론 아직 아주 많이 미숙한 수준의 개발자입니다. 스스로를 개발자라 부르기도 민망한 처지입니다. 하지만 앞으로 브런치에 글도 올리고 열심히 일하면서 성장하는 모습 보여드리겠습니다. 감사합니다. </p>\n"},{"id":"544","title":"[Challenge] Portfolio Page 만들기","date":"2016-06-05T11:17:26.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=544","_content":"Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;[개인 Portfoilo Page 만들기](https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage)&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.\n\n이전과 마찬가지로 [CodePen](http://codepen.io/)을 사용합니다. 역시나 [예시](https://codepen.io/FreeCodeCamp/full/YqLyXB/)를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.\n\n며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 [포트폴리오](http://codepen.io/rabbylab/full/gMOOBK/)를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.\n\n이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)\n\n아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.\n\n이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.","source":"_posts/challenge-portfolio-page.md","raw":"---\nid: 544\ntitle: '[Challenge] Portfolio Page 만들기'\ndate: 2016-06-05T20:17:26+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=544\npermalink: /challenge-portfolio-page/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - freecodecamp\n---\nTribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;[개인 Portfoilo Page 만들기](https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage)&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.\n\n이전과 마찬가지로 [CodePen](http://codepen.io/)을 사용합니다. 역시나 [예시](https://codepen.io/FreeCodeCamp/full/YqLyXB/)를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.\n\n며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 [포트폴리오](http://codepen.io/rabbylab/full/gMOOBK/)를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.\n\n이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)\n\n아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.\n\n이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.","slug":"/challenge-portfolio-page/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1ms0001i3vgixhw5drm","content":"<p>Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;<a href=\"https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage\" target=\"_blank\" rel=\"external\">개인 Portfoilo Page 만들기</a>&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.</p>\n<p>이전과 마찬가지로 <a href=\"http://codepen.io/\" target=\"_blank\" rel=\"external\">CodePen</a>을 사용합니다. 역시나 <a href=\"https://codepen.io/FreeCodeCamp/full/YqLyXB/\" target=\"_blank\" rel=\"external\">예시</a>를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.</p>\n<p>며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 <a href=\"http://codepen.io/rabbylab/full/gMOOBK/\" target=\"_blank\" rel=\"external\">포트폴리오</a>를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.</p>\n<p>이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)</section></p>\n<p>아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.</p>\n<p>이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.</p>\n","excerpt":"","more":"<p>Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;<a href=\"https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage\">개인 Portfoilo Page 만들기</a>&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.</p>\n<p>이전과 마찬가지로 <a href=\"http://codepen.io/\">CodePen</a>을 사용합니다. 역시나 <a href=\"https://codepen.io/FreeCodeCamp/full/YqLyXB/\">예시</a>를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.</p>\n<p>며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 <a href=\"http://codepen.io/rabbylab/full/gMOOBK/\">포트폴리오</a>를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.</p>\n<p>이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)</p>\n<p>아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.</p>\n<p>이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.</p>\n"},{"id":"531","title":"[CSS] Color, Hex Code and RGB","date":"2016-05-12T06:21:07.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=531","_content":"CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.\n\n**Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span>**\n  \n우선은 Hexadecimal Code의 준말인 Hex Code로 `#FF0000`처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.\n\n해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.\n\n  * 샵(#)기호 이후의 여섯자리의 숫자가 온다.\n  * 첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.\n  * 세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.\n  * 다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.\n  * 숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.\n\n예를 들어 `#FF0000`의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 `#00FF00`는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256\\*256\\*256 만큼입니다. 약 1,600만개입니다.\n\n**RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)**\n  \n다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 `rgb(255, 0, 0)`처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?","source":"_posts/css-color-hex-code-and-rgb.md","raw":"---\nid: 531\ntitle: '[CSS] Color, Hex Code and RGB'\ndate: 2016-05-12T15:21:07+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=531\npermalink: /css-color-hex-code-and-rgb/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - css\n---\nCSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.\n\n**Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span>**\n  \n우선은 Hexadecimal Code의 준말인 Hex Code로 `#FF0000`처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.\n\n해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.\n\n  * 샵(#)기호 이후의 여섯자리의 숫자가 온다.\n  * 첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.\n  * 세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.\n  * 다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.\n  * 숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.\n\n예를 들어 `#FF0000`의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 `#00FF00`는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256\\*256\\*256 만큼입니다. 약 1,600만개입니다.\n\n**RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)**\n  \n다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 `rgb(255, 0, 0)`처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?","slug":"/css-color-hex-code-and-rgb/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1n20004i3vgt61cpqvh","content":"<p>CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.</p>\n<p><strong>Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span></strong></p>\n<p>우선은 Hexadecimal Code의 준말인 Hex Code로 <code>#FF0000</code>처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.</p>\n<p>해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.</p>\n<ul>\n<li>샵(#)기호 이후의 여섯자리의 숫자가 온다.</li>\n<li>첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.</li>\n<li>세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.</li>\n<li>다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.</li>\n<li>숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.</li>\n</ul>\n<p>예를 들어 <code>#FF0000</code>의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 <code>#00FF00</code>는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256*256*256 만큼입니다. 약 1,600만개입니다.</p>\n<p><strong>RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)</strong></p>\n<p>다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 <code>rgb(255, 0, 0)</code>처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?</p>\n","excerpt":"","more":"<p>CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.</p>\n<p><strong>Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span></strong></p>\n<p>우선은 Hexadecimal Code의 준말인 Hex Code로 <code>#FF0000</code>처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.</p>\n<p>해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.</p>\n<ul>\n<li>샵(#)기호 이후의 여섯자리의 숫자가 온다.</li>\n<li>첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.</li>\n<li>세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.</li>\n<li>다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.</li>\n<li>숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.</li>\n</ul>\n<p>예를 들어 <code>#FF0000</code>의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 <code>#00FF00</code>는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256*256*256 만큼입니다. 약 1,600만개입니다.</p>\n<p><strong>RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)</strong></p>\n<p>다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 <code>rgb(255, 0, 0)</code>처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?</p>\n"},{"id":"520","title":"[CSS] Style Override","date":"2016-05-11T06:52:47.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=520","_content":"CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.\n\nCSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.\n\n예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 `<h1>`이 주황색으로 표기됩니다.\n\n```\n<style>\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  #orange-text {\n    color: orange;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n</style>\n\n<h1 id=\"orange-text\" class=\"pink-text blue-text\">Hello World!</h1> //주황색\n```\n\nid 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 `style=\"color: white\"`를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.\n\n하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 `!important`를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, `color: pink !important;`를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.\n\n**정리하자면 CSS Style의 우선순위는**\n\n  1. **동일한 class일 경우 가장 마지막에 선언된 Style이 높다.**\n  2. **(1번을 포함하고) class보다 id가 높다.**\n  3. **id보다 in-line style이 높다.**\n  4. **!important는 앞선 모든 것보다 높다.**\n\n**라고 정의할 수 있습니다.**","source":"_posts/css-style-override.md","raw":"---\nid: 520\ntitle: '[CSS] Style Override'\ndate: 2016-05-11T15:52:47+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=520\npermalink: /css-style-override/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - css\n---\nCSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.\n\nCSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.\n\n예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 `<h1>`이 주황색으로 표기됩니다.\n\n```\n<style>\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  #orange-text {\n    color: orange;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n</style>\n\n<h1 id=\"orange-text\" class=\"pink-text blue-text\">Hello World!</h1> //주황색\n```\n\nid 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 `style=\"color: white\"`를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.\n\n하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 `!important`를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, `color: pink !important;`를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.\n\n**정리하자면 CSS Style의 우선순위는**\n\n  1. **동일한 class일 경우 가장 마지막에 선언된 Style이 높다.**\n  2. **(1번을 포함하고) class보다 id가 높다.**\n  3. **id보다 in-line style이 높다.**\n  4. **!important는 앞선 모든 것보다 높다.**\n\n**라고 정의할 수 있습니다.**","slug":"/css-style-override/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1n40005i3vgo20w2hqj","content":"<p>CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.</p>\n<p>CSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.</p>\n<p>예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n<p>다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 <code>&lt;h1&gt;</code>이 주황색으로 표기됩니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">  body &#123;</div><div class=\"line\">    background-color: black;</div><div class=\"line\">    font-family: Monospace;</div><div class=\"line\">    color: green;</div><div class=\"line\">  &#125;</div><div class=\"line\">  #orange-text &#123;</div><div class=\"line\">    color: orange;</div><div class=\"line\">  &#125;</div><div class=\"line\">  .pink-text &#123;</div><div class=\"line\">    color: pink;</div><div class=\"line\">  &#125;</div><div class=\"line\">  .blue-text &#123;</div><div class=\"line\">    color: blue;</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;h1 id=&quot;orange-text&quot; class=&quot;pink-text blue-text&quot;&gt;Hello World!&lt;/h1&gt; //주황색</div></pre></td></tr></table></figure>\n<p>id 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 <code>style=&quot;color: white&quot;</code>를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.</p>\n<p>하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 <code>!important</code>를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, <code>color: pink !important;</code>를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.</p>\n<p><strong>정리하자면 CSS Style의 우선순위는</strong></p>\n<ol>\n<li><strong>동일한 class일 경우 가장 마지막에 선언된 Style이 높다.</strong></li>\n<li><strong>(1번을 포함하고) class보다 id가 높다.</strong></li>\n<li><strong>id보다 in-line style이 높다.</strong></li>\n<li><strong>!important는 앞선 모든 것보다 높다.</strong></li>\n</ol>\n<p><strong>라고 정의할 수 있습니다.</strong></p>\n","excerpt":"","more":"<p>CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.</p>\n<p>CSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.</p>\n<p>예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n<p>다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 <code>&lt;h1&gt;</code>이 주황색으로 표기됩니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">  body &#123;</div><div class=\"line\">    background-color: black;</div><div class=\"line\">    font-family: Monospace;</div><div class=\"line\">    color: green;</div><div class=\"line\">  &#125;</div><div class=\"line\">  #orange-text &#123;</div><div class=\"line\">    color: orange;</div><div class=\"line\">  &#125;</div><div class=\"line\">  .pink-text &#123;</div><div class=\"line\">    color: pink;</div><div class=\"line\">  &#125;</div><div class=\"line\">  .blue-text &#123;</div><div class=\"line\">    color: blue;</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;h1 id=&quot;orange-text&quot; class=&quot;pink-text blue-text&quot;&gt;Hello World!&lt;/h1&gt; //주황색</div></pre></td></tr></table></figure>\n<p>id 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 <code>style=&quot;color: white&quot;</code>를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.</p>\n<p>하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 <code>!important</code>를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, <code>color: pink !important;</code>를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.</p>\n<p><strong>정리하자면 CSS Style의 우선순위는</strong></p>\n<ol>\n<li><strong>동일한 class일 경우 가장 마지막에 선언된 Style이 높다.</strong></li>\n<li><strong>(1번을 포함하고) class보다 id가 높다.</strong></li>\n<li><strong>id보다 in-line style이 높다.</strong></li>\n<li><strong>!important는 앞선 모든 것보다 높다.</strong></li>\n</ol>\n<p><strong>라고 정의할 수 있습니다.</strong></p>\n"},{"id":"479","title":"COIN, 함께 성장하기","date":"2016-03-26T17:08:18.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=479","_content":"학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.\n\n1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;**COIN(코인)**&#8216; 입니다. **코**딩**인**터뷰 준비하는 사람들의 모임 혹은 **코**딩하는 **인**간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 <코딩인터뷰 완전분석>이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.\n\nCOIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.","source":"_posts/coin.md","raw":"---\nid: 479\ntitle: COIN, 함께 성장하기\ndate: 2016-03-27T02:08:18+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=479\npermalink: /coin/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - coin\n---\n학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.\n\n1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;**COIN(코인)**&#8216; 입니다. **코**딩**인**터뷰 준비하는 사람들의 모임 혹은 **코**딩하는 **인**간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 <코딩인터뷰 완전분석>이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.\n\nCOIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.","slug":"/coin/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1nl0006i3vg9d23oc28","content":"<p>학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.</p>\n<p>1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;<strong>COIN(코인)</strong>&#8216; 입니다. <strong>코</strong>딩<strong>인</strong>터뷰 준비하는 사람들의 모임 혹은 <strong>코</strong>딩하는 <strong>인</strong>간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 &lt;코딩인터뷰 완전분석&gt;이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.</p>\n<p>COIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.</p>\n","excerpt":"","more":"<p>학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.</p>\n<p>1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;<strong>COIN(코인)</strong>&#8216; 입니다. <strong>코</strong>딩<strong>인</strong>터뷰 준비하는 사람들의 모임 혹은 <strong>코</strong>딩하는 <strong>인</strong>간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 &lt;코딩인터뷰 완전분석&gt;이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.</p>\n<p>COIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.</p>\n"},{"id":"570","title":"[Daily Commit] Today I Learned","date":"2016-07-17T14:19:46.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=570","_content":"한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.\n\n이전부터 다른 블로그에서 [&#8216;일일커밋&#8217;에 관한 글](https://blog.outsider.ne.kr/1141)을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 [Jay Jin님의 블로그](https://milooy.wordpress.com/2015/10/08/daily-commit/)를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 [Jay Jin님의 Github](https://github.com/milooy/TIL)을 찾아가 기본 골격을 본따서 [저만의 TIL](https://github.com/joeunha/TIL)을 구성했습니다.\n\nTIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.\n\n우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.","source":"_posts/daily-commit-today-i-learned.md","raw":"---\nid: 570\ntitle: '[Daily Commit] Today I Learned'\ndate: 2016-07-17T23:19:46+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=570\npermalink: /daily-commit-today-i-learned/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - daily-commit\n---\n한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.\n\n이전부터 다른 블로그에서 [&#8216;일일커밋&#8217;에 관한 글](https://blog.outsider.ne.kr/1141)을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 [Jay Jin님의 블로그](https://milooy.wordpress.com/2015/10/08/daily-commit/)를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 [Jay Jin님의 Github](https://github.com/milooy/TIL)을 찾아가 기본 골격을 본따서 [저만의 TIL](https://github.com/joeunha/TIL)을 구성했습니다.\n\nTIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.\n\n우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.","slug":"/daily-commit-today-i-learned/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1nz0009i3vgfyfujq1f","content":"<p>한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.</p>\n<p>이전부터 다른 블로그에서 <a href=\"https://blog.outsider.ne.kr/1141\" target=\"_blank\" rel=\"external\">&#8216;일일커밋&#8217;에 관한 글</a>을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 <a href=\"https://milooy.wordpress.com/2015/10/08/daily-commit/\" target=\"_blank\" rel=\"external\">Jay Jin님의 블로그</a>를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 <a href=\"https://github.com/milooy/TIL\" target=\"_blank\" rel=\"external\">Jay Jin님의 Github</a>을 찾아가 기본 골격을 본따서 <a href=\"https://github.com/joeunha/TIL\" target=\"_blank\" rel=\"external\">저만의 TIL</a>을 구성했습니다.</p>\n<p>TIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.</p>\n<p>우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.</p>\n","excerpt":"","more":"<p>한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.</p>\n<p>이전부터 다른 블로그에서 <a href=\"https://blog.outsider.ne.kr/1141\">&#8216;일일커밋&#8217;에 관한 글</a>을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 <a href=\"https://milooy.wordpress.com/2015/10/08/daily-commit/\">Jay Jin님의 블로그</a>를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 <a href=\"https://github.com/milooy/TIL\">Jay Jin님의 Github</a>을 찾아가 기본 골격을 본따서 <a href=\"https://github.com/joeunha/TIL\">저만의 TIL</a>을 구성했습니다.</p>\n<p>TIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.</p>\n<p>우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.</p>\n"},{"id":"464","title":"fork(), execlp(), wait() 함수","date":"2016-03-25T15:27:03.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=464","_content":"운영체제를 배우고 있습니다. <a href=\"http://rabbylab.xyz/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%8a%a4%eb%a0%88%eb%93%9c/\" target=\"_blank\">이전 글</a>에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 fork(), execlp(), wait() 함수를 살펴보겠습니다.\n\n이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.\n\n먼저 fork() 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.\n\n이제 아래의 코드를 보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n   \n   return 0;\n}\n</pre>\n\n우리에게 너무나 익숙한 Hello, World! 를 출력하는 코드입니다. printf 앞에 fork 함수가 자리하고 있습니다. 이 코드의 결과물은 Hello, World! 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. fork 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 Hello, World!를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 fork 함수를 몇번 사용해야 할까요? 정답은 세번입니다.\n\n저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. &#8216;1 &#8211; 2 &#8211; 4 &#8211; 8&#8217; 하나가 두개가 되고 두개가 네개가 되고&#8230; 두배씩 커지는거죠. 이 간단한 원리를&#8230; 저는 종이 몇장을 찢어가며 고민했습니다.\n\n이제 exec 식구(family)들을 만나볼 시간입니다. execlp 함수는 가족이 많습니다. exec 가문이죠. 가족 구성원은 execl, execlp, execle, execv, execvp, execvpe 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 execlp 만 다루겠습니다. 코드 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n</pre>\n\n이 코드도 앞선 fork 예제처럼 Hello, World! 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 execlp 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 Hello, world! 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 &#8220;./hello&#8221; 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 NULL 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.\n\n이제 마지막 wait입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n   \n   return 0;\n}\n</pre>\n\n결과부터 생각해볼까요? 위의 if문 안에 있는 execlp는 같은 프로그램을 호출한 것이라면 Hello, World!가 출력될 것입니다. 그리고 다른 출력문인 This is wait function test! 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child\\_pid라는 변수는 fork()의 리턴 값을 받습니다. 이때 알아야할 것이 fork()가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 fork()가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child\\_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 execlp를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. wait 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?\n\n위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.","source":"_posts/fork-execlp-wait.md","raw":"---\nid: 464\ntitle: fork(), execlp(), wait() 함수\ndate: 2016-03-26T00:27:03+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=464\npermalink: /fork-execlp-wait/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - cs-basic\n---\n운영체제를 배우고 있습니다. <a href=\"http://rabbylab.xyz/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%8a%a4%eb%a0%88%eb%93%9c/\" target=\"_blank\">이전 글</a>에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 fork(), execlp(), wait() 함수를 살펴보겠습니다.\n\n이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.\n\n먼저 fork() 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.\n\n이제 아래의 코드를 보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n   \n   return 0;\n}\n</pre>\n\n우리에게 너무나 익숙한 Hello, World! 를 출력하는 코드입니다. printf 앞에 fork 함수가 자리하고 있습니다. 이 코드의 결과물은 Hello, World! 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. fork 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 Hello, World!를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 fork 함수를 몇번 사용해야 할까요? 정답은 세번입니다.\n\n저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. &#8216;1 &#8211; 2 &#8211; 4 &#8211; 8&#8217; 하나가 두개가 되고 두개가 네개가 되고&#8230; 두배씩 커지는거죠. 이 간단한 원리를&#8230; 저는 종이 몇장을 찢어가며 고민했습니다.\n\n이제 exec 식구(family)들을 만나볼 시간입니다. execlp 함수는 가족이 많습니다. exec 가문이죠. 가족 구성원은 execl, execlp, execle, execv, execvp, execvpe 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 execlp 만 다루겠습니다. 코드 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n</pre>\n\n이 코드도 앞선 fork 예제처럼 Hello, World! 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 execlp 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 Hello, world! 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 &#8220;./hello&#8221; 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 NULL 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.\n\n이제 마지막 wait입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n   \n   return 0;\n}\n</pre>\n\n결과부터 생각해볼까요? 위의 if문 안에 있는 execlp는 같은 프로그램을 호출한 것이라면 Hello, World!가 출력될 것입니다. 그리고 다른 출력문인 This is wait function test! 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child\\_pid라는 변수는 fork()의 리턴 값을 받습니다. 이때 알아야할 것이 fork()가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 fork()가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child\\_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 execlp를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. wait 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?\n\n위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.","slug":"/fork-execlp-wait/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1pk000xi3vgva65fbay","content":"<p>운영체제를 배우고 있습니다. <a href=\"http://rabbylab.xyz/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%8a%a4%eb%a0%88%eb%93%9c/\" target=\"_blank\">이전 글</a>에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 fork(), execlp(), wait() 함수를 살펴보겠습니다.</p>\n<p>이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.</p>\n<p>먼저 fork() 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.</p>\n<p>이제 아래의 코드를 보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n\n   return 0;\n}\n</pre>\n\n<p>우리에게 너무나 익숙한 Hello, World! 를 출력하는 코드입니다. printf 앞에 fork 함수가 자리하고 있습니다. 이 코드의 결과물은 Hello, World! 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. fork 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 Hello, World!를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 fork 함수를 몇번 사용해야 할까요? 정답은 세번입니다.</p>\n<p>저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. &#8216;1 &#8211; 2 &#8211; 4 &#8211; 8&#8217; 하나가 두개가 되고 두개가 네개가 되고&#8230; 두배씩 커지는거죠. 이 간단한 원리를&#8230; 저는 종이 몇장을 찢어가며 고민했습니다.</p>\n<p>이제 exec 식구(family)들을 만나볼 시간입니다. execlp 함수는 가족이 많습니다. exec 가문이죠. 가족 구성원은 execl, execlp, execle, execv, execvp, execvpe 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 execlp 만 다루겠습니다. 코드 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n</pre>\n\n<p>이 코드도 앞선 fork 예제처럼 Hello, World! 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 execlp 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 Hello, world! 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 &#8220;./hello&#8221; 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 NULL 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.</p>\n<p>이제 마지막 wait입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n\n   return 0;\n}\n</pre>\n\n<p>결과부터 생각해볼까요? 위의 if문 안에 있는 execlp는 같은 프로그램을 호출한 것이라면 Hello, World!가 출력될 것입니다. 그리고 다른 출력문인 This is wait function test! 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child_pid라는 변수는 fork()의 리턴 값을 받습니다. 이때 알아야할 것이 fork()가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 fork()가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 execlp를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. wait 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?</p>\n<p>위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.</p>\n","excerpt":"","more":"<p>운영체제를 배우고 있습니다. <a href=\"http://rabbylab.xyz/%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%8a%a4%eb%a0%88%eb%93%9c/\" target=\"_blank\">이전 글</a>에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 fork(), execlp(), wait() 함수를 살펴보겠습니다.</p>\n<p>이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.</p>\n<p>먼저 fork() 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.</p>\n<p>이제 아래의 코드를 보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n\n   return 0;\n}\n</pre>\n\n<p>우리에게 너무나 익숙한 Hello, World! 를 출력하는 코드입니다. printf 앞에 fork 함수가 자리하고 있습니다. 이 코드의 결과물은 Hello, World! 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. fork 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 Hello, World!를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 fork 함수를 몇번 사용해야 할까요? 정답은 세번입니다.</p>\n<p>저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. &#8216;1 &#8211; 2 &#8211; 4 &#8211; 8&#8217; 하나가 두개가 되고 두개가 네개가 되고&#8230; 두배씩 커지는거죠. 이 간단한 원리를&#8230; 저는 종이 몇장을 찢어가며 고민했습니다.</p>\n<p>이제 exec 식구(family)들을 만나볼 시간입니다. execlp 함수는 가족이 많습니다. exec 가문이죠. 가족 구성원은 execl, execlp, execle, execv, execvp, execvpe 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 execlp 만 다루겠습니다. 코드 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n</pre>\n\n<p>이 코드도 앞선 fork 예제처럼 Hello, World! 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 execlp 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 Hello, world! 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 &#8220;./hello&#8221; 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 NULL 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.</p>\n<p>이제 마지막 wait입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n\n   return 0;\n}\n</pre>\n\n<p>결과부터 생각해볼까요? 위의 if문 안에 있는 execlp는 같은 프로그램을 호출한 것이라면 Hello, World!가 출력될 것입니다. 그리고 다른 출력문인 This is wait function test! 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child_pid라는 변수는 fork()의 리턴 값을 받습니다. 이때 알아야할 것이 fork()가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 fork()가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 execlp를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. wait 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?</p>\n<p>위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.</p>\n"},{"title":"[오늘의 함수] pick","date":"2017-03-07T14:28:18.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pick 함수\n\n__자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.__ 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?\n\n#### 1번 - 어제의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.me',\n  };\n\nvar user_data = { // [2] 필요한 데이터\n  id: user_1.id,\n  first_name: user_1.first_name, \n  last_name: user_1.last_name\n  };\n\n$.post('/api/user_name/check', user_data)\n  .done(redirect('/main')); // [3] '오늘의 함수 redirect' 편을 참고하세요.\n```\n\n위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 `pick` 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. [underscore.js](underscorejs.org)라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.me',\n  };\n\nfunction pick(target, keys) {\n  return keys.reduce(function(obj, key) {\n    return obj[key] = target[key], obj;\n  }, {});\n}\n\n\nconsole.log(pick(user_1, ['age', 'id'])); // [2] 출력 결과는 { age: 28, id: 1 } 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.\n\n$.post('/api/user_name/check', pick(user_1, ['id', 'first_name', 'last_name'])) // [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.\n  .done(redirect('/main')); \n\n$.post('/api/city/check', pick(user_1, ['id', 'city']))\n  .done(redirect('/main'));\n```","source":"_posts/javascript-daily-function-1.md","raw":"---\ntitle: '[오늘의 함수] pick'\ndate: 2017-03-07 23:28:18\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pick 함수\n\n__자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.__ 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?\n\n#### 1번 - 어제의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.me',\n  };\n\nvar user_data = { // [2] 필요한 데이터\n  id: user_1.id,\n  first_name: user_1.first_name, \n  last_name: user_1.last_name\n  };\n\n$.post('/api/user_name/check', user_data)\n  .done(redirect('/main')); // [3] '오늘의 함수 redirect' 편을 참고하세요.\n```\n\n위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 `pick` 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. [underscore.js](underscorejs.org)라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.me',\n  };\n\nfunction pick(target, keys) {\n  return keys.reduce(function(obj, key) {\n    return obj[key] = target[key], obj;\n  }, {});\n}\n\n\nconsole.log(pick(user_1, ['age', 'id'])); // [2] 출력 결과는 { age: 28, id: 1 } 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.\n\n$.post('/api/user_name/check', pick(user_1, ['id', 'first_name', 'last_name'])) // [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.\n  .done(redirect('/main')); \n\n$.post('/api/city/check', pick(user_1, ['id', 'city']))\n  .done(redirect('/main'));\n```","slug":"javascript-daily-function-1","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1pu000zi3vg7y45t3ce","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pick-함수\"><a href=\"#pick-함수\" class=\"headerlink\" title=\"pick 함수\"></a>pick 함수</h2><p><strong>자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.</strong> 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></div><div class=\"line\">  id: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: <span class=\"string\">'Joeun'</span>,</div><div class=\"line\">  <span class=\"attr\">last_name</span>: <span class=\"string\">'Ha'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</div><div class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">'South Korea'</span>,</div><div class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">'Seoul'</span>,</div><div class=\"line\">  <span class=\"attr\">mobile_phone</span>: <span class=\"string\">'010-0000-0000'</span>,</div><div class=\"line\">  <span class=\"attr\">email</span>: <span class=\"string\">'imjoeunha@gmail.com'</span>,</div><div class=\"line\">  <span class=\"attr\">blog_url</span>: <span class=\"string\">'http://joeun.me'</span>,</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user_data = &#123; <span class=\"comment\">// [2] 필요한 데이터</span></div><div class=\"line\">  id: user_1.id,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: user_1.first_name, </div><div class=\"line\">  <span class=\"attr\">last_name</span>: user_1.last_name</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, user_data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); <span class=\"comment\">// [3] '오늘의 함수 redirect' 편을 참고하세요.</span></div></pre></td></tr></table></figure>\n<p>위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 <code>pick</code> 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. <a href=\"underscorejs.org\">underscore.js</a>라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></div><div class=\"line\">  id: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: <span class=\"string\">'Joeun'</span>,</div><div class=\"line\">  <span class=\"attr\">last_name</span>: <span class=\"string\">'Ha'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</div><div class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">'South Korea'</span>,</div><div class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">'Seoul'</span>,</div><div class=\"line\">  <span class=\"attr\">mobile_phone</span>: <span class=\"string\">'010-0000-0000'</span>,</div><div class=\"line\">  <span class=\"attr\">email</span>: <span class=\"string\">'imjoeunha@gmail.com'</span>,</div><div class=\"line\">  <span class=\"attr\">blog_url</span>: <span class=\"string\">'http://joeun.me'</span>,</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>(<span class=\"params\">target, keys</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</div><div class=\"line\">  &#125;, &#123;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(pick(user_1, [<span class=\"string\">'age'</span>, <span class=\"string\">'id'</span>])); <span class=\"comment\">// [2] 출력 결과는 &#123; age: 28, id: 1 &#125; 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.</span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'first_name'</span>, <span class=\"string\">'last_name'</span>])) <span class=\"comment\">// [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.</span></div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); </div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/city/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'city'</span>]))</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pick-함수\"><a href=\"#pick-함수\" class=\"headerlink\" title=\"pick 함수\"></a>pick 함수</h2><p><strong>자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.</strong> 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></div><div class=\"line\">  id: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: <span class=\"string\">'Joeun'</span>,</div><div class=\"line\">  <span class=\"attr\">last_name</span>: <span class=\"string\">'Ha'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</div><div class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">'South Korea'</span>,</div><div class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">'Seoul'</span>,</div><div class=\"line\">  <span class=\"attr\">mobile_phone</span>: <span class=\"string\">'010-0000-0000'</span>,</div><div class=\"line\">  <span class=\"attr\">email</span>: <span class=\"string\">'imjoeunha@gmail.com'</span>,</div><div class=\"line\">  <span class=\"attr\">blog_url</span>: <span class=\"string\">'http://joeun.me'</span>,</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user_data = &#123; <span class=\"comment\">// [2] 필요한 데이터</span></div><div class=\"line\">  id: user_1.id,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: user_1.first_name, </div><div class=\"line\">  <span class=\"attr\">last_name</span>: user_1.last_name</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, user_data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); <span class=\"comment\">// [3] '오늘의 함수 redirect' 편을 참고하세요.</span></div></pre></td></tr></table></figure>\n<p>위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 <code>pick</code> 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. <a href=\"underscorejs.org\">underscore.js</a>라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></div><div class=\"line\">  id: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"attr\">first_name</span>: <span class=\"string\">'Joeun'</span>,</div><div class=\"line\">  <span class=\"attr\">last_name</span>: <span class=\"string\">'Ha'</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</div><div class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">'South Korea'</span>,</div><div class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">'Seoul'</span>,</div><div class=\"line\">  <span class=\"attr\">mobile_phone</span>: <span class=\"string\">'010-0000-0000'</span>,</div><div class=\"line\">  <span class=\"attr\">email</span>: <span class=\"string\">'imjoeunha@gmail.com'</span>,</div><div class=\"line\">  <span class=\"attr\">blog_url</span>: <span class=\"string\">'http://joeun.me'</span>,</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>(<span class=\"params\">target, keys</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</div><div class=\"line\">  &#125;, &#123;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(pick(user_1, [<span class=\"string\">'age'</span>, <span class=\"string\">'id'</span>])); <span class=\"comment\">// [2] 출력 결과는 &#123; age: 28, id: 1 &#125; 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.</span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'first_name'</span>, <span class=\"string\">'last_name'</span>])) <span class=\"comment\">// [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.</span></div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); </div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/city/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'city'</span>]))</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</div></pre></td></tr></table></figure>"},{"id":"25","title":"블로그 및 운영자 소개","date":"2015-07-17T11:19:54.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=25","geo_public":[0],"_content":"<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br /> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br /> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br /> 아래의 메일로 연락주시기 바랍니다.<br /> imjoeunha@gmail.com\n</p>","source":"_posts/introduction-to-blog.md","raw":"---\nid: 25\ntitle: 블로그 및 운영자 소개\ndate: 2015-07-17T20:19:54+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=25\ngeo_public:\n  - 0\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - introduction\n---\n<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br /> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br /> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br /> 아래의 메일로 연락주시기 바랍니다.<br /> imjoeunha@gmail.com\n</p>","slug":"introduction-to-blog","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1q50011i3vg15q45mna","content":"<h5 style=\"text-align: center;\"><br>  <img src=\"/images/profile-1.png\" alt=\"\"><br></h5>\n\n<h5 style=\"text-align: center;\"><br>  RABBY LAB에 오신 걸 환영합니다.<br></h5>\n\n<p style=\"text-align: center;\"><br>  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.<br></p>\n\n<p style=\"text-align: center;\"><br>  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.<br></p>\n\n<p style=\"text-align: center;\"><br>  부족한 점에 대한 조언은 언제나 환영합니다.<br> 아래의 메일로 연락주시기 바랍니다.<br> imjoeunha@gmail.com<br></p>","excerpt":"","more":"<h5 style=\"text-align: center;\"><br>  <img src=\"/images/profile-1.png\" alt=\"\"><br></h5>\n\n<h5 style=\"text-align: center;\"><br>  RABBY LAB에 오신 걸 환영합니다.<br></h5>\n\n<p style=\"text-align: center;\"><br>  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.<br></p>\n\n<p style=\"text-align: center;\"><br>  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br /> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br /> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.<br></p>\n\n<p style=\"text-align: center;\"><br>  부족한 점에 대한 조언은 언제나 환영합니다.<br /> 아래의 메일로 연락주시기 바랍니다.<br /> imjoeunha@gmail.com<br></p>"},{"title":"[오늘의 함수] confirm","date":"2017-03-15T14:37:46.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## confirm 함수 \n\n오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 `confirm` 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.\n\n이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.\n#### index.html\n```html\n<ul>\n  <li>\n    <span>요소 1번</span>\n    <button class=\"delete\">삭제</button>\n  </li>\n</ul>\n```\n\n#### 1번 - 어제의 함수\n```javascript\n$('li').on('click', 'button.delete', function(e) {\n  if (confirm('Are you sure?')) { // [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.\n    $(e.delegateTarget).remove(); // [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.\n  } \n})\n```\n\n`confirm` 함수는 사용자가 어떤 버튼을 누르는가에 따라 `true`, `false` 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 `confirm` 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 `_`를 붙였습니다.)\n\n#### 2번 - 오늘의 함수\n```javascript\nfunction _confirm(message, yes_fn, no_fn) {\n  return confirm(message) ? yes_fn() : no_fn(); // [1] 분기를 함수 안으로 가져왔습니다.\n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, function() { return false; }) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다.\n})\n```","source":"_posts/javascript-daily-function-3.md","raw":"---\ntitle: '[오늘의 함수] confirm'\ndate: 2017-03-15 23:37:46\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## confirm 함수 \n\n오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 `confirm` 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.\n\n이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.\n#### index.html\n```html\n<ul>\n  <li>\n    <span>요소 1번</span>\n    <button class=\"delete\">삭제</button>\n  </li>\n</ul>\n```\n\n#### 1번 - 어제의 함수\n```javascript\n$('li').on('click', 'button.delete', function(e) {\n  if (confirm('Are you sure?')) { // [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.\n    $(e.delegateTarget).remove(); // [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.\n  } \n})\n```\n\n`confirm` 함수는 사용자가 어떤 버튼을 누르는가에 따라 `true`, `false` 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 `confirm` 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 `_`를 붙였습니다.)\n\n#### 2번 - 오늘의 함수\n```javascript\nfunction _confirm(message, yes_fn, no_fn) {\n  return confirm(message) ? yes_fn() : no_fn(); // [1] 분기를 함수 안으로 가져왔습니다.\n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, function() { return false; }) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다.\n})\n```","slug":"javascript-daily-function-3","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1q90013i3vgfnr6v9ak","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"confirm-함수\"><a href=\"#confirm-함수\" class=\"headerlink\" title=\"confirm 함수\"></a>confirm 함수</h2><p>오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 <code>confirm</code> 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.</p>\n<p>이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.</p>\n<h4 id=\"index-html\"><a href=\"#index-html\" class=\"headerlink\" title=\"index.html\"></a>index.html</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>요소 1번<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"delete\"</span>&gt;</span>삭제<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (confirm(<span class=\"string\">'Are you sure?'</span>)) &#123; <span class=\"comment\">// [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove(); <span class=\"comment\">// [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.</span></div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>confirm</code> 함수는 사용자가 어떤 버튼을 누르는가에 따라 <code>true</code>, <code>false</code> 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 <code>confirm</code> 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 <code>_</code>를 붙였습니다.)</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); <span class=\"comment\">// [1] 분기를 함수 안으로 가져왔습니다.</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"confirm-함수\"><a href=\"#confirm-함수\" class=\"headerlink\" title=\"confirm 함수\"></a>confirm 함수</h2><p>오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 <code>confirm</code> 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.</p>\n<p>이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.</p>\n<h4 id=\"index-html\"><a href=\"#index-html\" class=\"headerlink\" title=\"index.html\"></a>index.html</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>요소 1번<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"delete\"</span>&gt;</span>삭제<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (confirm(<span class=\"string\">'Are you sure?'</span>)) &#123; <span class=\"comment\">// [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove(); <span class=\"comment\">// [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.</span></div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>confirm</code> 함수는 사용자가 어떤 버튼을 누르는가에 따라 <code>true</code>, <code>false</code> 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 <code>confirm</code> 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 <code>_</code>를 붙였습니다.)</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); <span class=\"comment\">// [1] 분기를 함수 안으로 가져왔습니다.</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"title":"[오늘의 함수] redirect2","date":"2017-03-09T11:36:40.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect2 함수 \n\n첫번째로 소개해드렸던 `redirect` 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 __때론 URL이 유연하게 결정되어야할 필요가 있습니다.__ `post`방식이 아닌 `get`방식으로 서버와 통신해야할 경우가 있기 때문입니다.\n\n오늘의 예제는 `post`로 가져온 데이터의 아이디 값에 따라 `get`방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar redirect1 = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.\n    redirect1('/main/newsfeed?id=' + res.id); \n  }); \n```\n\n사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect2('/main/newsfeed?id=', 'id')); // [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. \n\n$.post('/api/post/update', data)\n  .done(redirect2('/main/editor?no=', 'no'));\n\n$.post('/api/post/delete', data)\n  .done(redirect2('/main/home')); // [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.\n```","source":"_posts/javascript-daily-function-2.md","raw":"---\ntitle: '[오늘의 함수] redirect2'\ndate: 2017-03-09 20:36:40\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect2 함수 \n\n첫번째로 소개해드렸던 `redirect` 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 __때론 URL이 유연하게 결정되어야할 필요가 있습니다.__ `post`방식이 아닌 `get`방식으로 서버와 통신해야할 경우가 있기 때문입니다.\n\n오늘의 예제는 `post`로 가져온 데이터의 아이디 값에 따라 `get`방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar redirect1 = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.\n    redirect1('/main/newsfeed?id=' + res.id); \n  }); \n```\n\n사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect2('/main/newsfeed?id=', 'id')); // [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. \n\n$.post('/api/post/update', data)\n  .done(redirect2('/main/editor?no=', 'no'));\n\n$.post('/api/post/delete', data)\n  .done(redirect2('/main/home')); // [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.\n```","slug":"javascript-daily-function-2","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1qe0015i3vgdeusrqvg","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect2-함수\"><a href=\"#redirect2-함수\" class=\"headerlink\" title=\"redirect2 함수\"></a>redirect2 함수</h2><p>첫번째로 소개해드렸던 <code>redirect</code> 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 <strong>때론 URL이 유연하게 결정되어야할 필요가 있습니다.</strong> <code>post</code>방식이 아닌 <code>get</code>방식으로 서버와 통신해야할 경우가 있기 때문입니다.</p>\n<p>오늘의 예제는 <code>post</code>로 가져온 데이터의 아이디 값에 따라 <code>get</code>방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.</span></div><div class=\"line\">    redirect1(<span class=\"string\">'/main/newsfeed?id='</span> + res.id); </div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. </span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/editor?no='</span>, <span class=\"string\">'no'</span>));</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/home'</span>)); <span class=\"comment\">// [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect2-함수\"><a href=\"#redirect2-함수\" class=\"headerlink\" title=\"redirect2 함수\"></a>redirect2 함수</h2><p>첫번째로 소개해드렸던 <code>redirect</code> 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 <strong>때론 URL이 유연하게 결정되어야할 필요가 있습니다.</strong> <code>post</code>방식이 아닌 <code>get</code>방식으로 서버와 통신해야할 경우가 있기 때문입니다.</p>\n<p>오늘의 예제는 <code>post</code>로 가져온 데이터의 아이디 값에 따라 <code>get</code>방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.</span></div><div class=\"line\">    redirect1(<span class=\"string\">'/main/newsfeed?id='</span> + res.id); </div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. </span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/editor?no='</span>, <span class=\"string\">'no'</span>));</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</div><div class=\"line\">  .done(redirect2(<span class=\"string\">'/main/home'</span>)); <span class=\"comment\">// [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.</span></div></pre></td></tr></table></figure>"},{"title":"[오늘의 함수] pipe","date":"2017-03-23T13:48:59.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pipe 함수\n\n미리 예고드린 것처럼 오늘은 `pipe` 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 `compose` 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 `pipe` 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.\n\n#### (1) 어제의 함수 - 함수의 연속 실행\n```javascript\nfunction add10(num) {\n  return num + 10;\n}\n\nvar result = add10(add10(add10(5))); // [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.\nconsole.log(result); // [2] 결과는 35가 나옵니다.\n```\n\n아주 간단한 예제입니다. `add10` 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 __함수가 값으로 쓰인다는 점__입니다. 가장 좌측에 위치한 `add10` 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. \n\n이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 `pipe` 함수를 만나보겠습니다.\n\n#### (2) 오늘의 함수 - pipe 함수\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n\nvar add30 = pipe(add10, add10, add10); \n// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.\n\nvar result1 = add30(5); // [4] 만들어진 함수로 결과를 만듭니다.\nvar result2 = add30(13); // [5] pipe로 만들어진 함수는 재사용 가능합니다.\n\nconsole.log(result1); // 35\nconsole.log(result2); // 43\n```\n","source":"_posts/javascript-daily-function-5.md","raw":"---\ntitle: '[오늘의 함수] pipe'\ndate: 2017-03-23 22:48:59\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pipe 함수\n\n미리 예고드린 것처럼 오늘은 `pipe` 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 `compose` 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 `pipe` 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.\n\n#### (1) 어제의 함수 - 함수의 연속 실행\n```javascript\nfunction add10(num) {\n  return num + 10;\n}\n\nvar result = add10(add10(add10(5))); // [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.\nconsole.log(result); // [2] 결과는 35가 나옵니다.\n```\n\n아주 간단한 예제입니다. `add10` 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 __함수가 값으로 쓰인다는 점__입니다. 가장 좌측에 위치한 `add10` 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. \n\n이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 `pipe` 함수를 만나보겠습니다.\n\n#### (2) 오늘의 함수 - pipe 함수\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n\nvar add30 = pipe(add10, add10, add10); \n// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.\n\nvar result1 = add30(5); // [4] 만들어진 함수로 결과를 만듭니다.\nvar result2 = add30(13); // [5] pipe로 만들어진 함수는 재사용 가능합니다.\n\nconsole.log(result1); // 35\nconsole.log(result2); // 43\n```\n","slug":"javascript-daily-function-5","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1qj0019i3vgay9bdgkr","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe-함수\"><a href=\"#pipe-함수\" class=\"headerlink\" title=\"pipe 함수\"></a>pipe 함수</h2><p>미리 예고드린 것처럼 오늘은 <code>pipe</code> 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 <code>compose</code> 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 <code>pipe</code> 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-함수의-연속-실행\"><a href=\"#1-어제의-함수-함수의-연속-실행\" class=\"headerlink\" title=\"(1) 어제의 함수 - 함수의 연속 실행\"></a>(1) 어제의 함수 - 함수의 연속 실행</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = add10(add10(add10(<span class=\"number\">5</span>))); <span class=\"comment\">// [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [2] 결과는 35가 나옵니다.</span></div></pre></td></tr></table></figure>\n<p>아주 간단한 예제입니다. <code>add10</code> 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 <strong>함수가 값으로 쓰인다는 점</strong>입니다. 가장 좌측에 위치한 <code>add10</code> 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. </p>\n<p>이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 <code>pipe</code> 함수를 만나보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-pipe-함수\"><a href=\"#2-오늘의-함수-pipe-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수 - pipe 함수\"></a>(2) 오늘의 함수 - pipe 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </div><div class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </div><div class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func(value);</div><div class=\"line\">    &#125;, seed);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> add30 = pipe(add10, add10, add10); </div><div class=\"line\"><span class=\"comment\">// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result1 = add30(<span class=\"number\">5</span>); <span class=\"comment\">// [4] 만들어진 함수로 결과를 만듭니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> result2 = add30(<span class=\"number\">13</span>); <span class=\"comment\">// [5] pipe로 만들어진 함수는 재사용 가능합니다.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result1); <span class=\"comment\">// 35</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// 43</span></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe-함수\"><a href=\"#pipe-함수\" class=\"headerlink\" title=\"pipe 함수\"></a>pipe 함수</h2><p>미리 예고드린 것처럼 오늘은 <code>pipe</code> 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 <code>compose</code> 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 <code>pipe</code> 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-함수의-연속-실행\"><a href=\"#1-어제의-함수-함수의-연속-실행\" class=\"headerlink\" title=\"(1) 어제의 함수 - 함수의 연속 실행\"></a>(1) 어제의 함수 - 함수의 연속 실행</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result = add10(add10(add10(<span class=\"number\">5</span>))); <span class=\"comment\">// [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [2] 결과는 35가 나옵니다.</span></div></pre></td></tr></table></figure>\n<p>아주 간단한 예제입니다. <code>add10</code> 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 <strong>함수가 값으로 쓰인다는 점</strong>입니다. 가장 좌측에 위치한 <code>add10</code> 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. </p>\n<p>이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 <code>pipe</code> 함수를 만나보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-pipe-함수\"><a href=\"#2-오늘의-함수-pipe-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수 - pipe 함수\"></a>(2) 오늘의 함수 - pipe 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </div><div class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </div><div class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></div><div class=\"line\">      <span class=\"keyword\">return</span> func(value);</div><div class=\"line\">    &#125;, seed);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> add30 = pipe(add10, add10, add10); </div><div class=\"line\"><span class=\"comment\">// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> result1 = add30(<span class=\"number\">5</span>); <span class=\"comment\">// [4] 만들어진 함수로 결과를 만듭니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> result2 = add30(<span class=\"number\">13</span>); <span class=\"comment\">// [5] pipe로 만들어진 함수는 재사용 가능합니다.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result1); <span class=\"comment\">// 35</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// 43</span></div></pre></td></tr></table></figure>\n"},{"title":"[오늘의 함수] identity, always","date":"2017-03-20T14:41:48.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## identity, always 함수 \n\n오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 `identity`와 `always` 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.\n\n#### (1) 오늘의 함수 - identity와 always\n```javascript\nfunction identity(value) {\n  return value;\n}\n\nfunction always(value) {\n  return function() {\n    return value;\n  }\n}\n\nconsole.log(identity(10)); // 10\nconsole.log(always(10)()); // 10\n```\n\n정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 `confirm` 함수를 사용해서 예시를 만들어보겠습니다.\n\n#### (2) 오늘의 함수 - confirm 함수와의 콜라보 1\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { // [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.\n  return confirm(message) ? yes_fn() : no_fn(); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, always(false)) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.\n})\n```\n\n주목하셔야할 부분은 역시 `always` 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 `function() { return false }`로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 '_항상 false를 반환하는구나_'하고 이해가 됩니다. \n\n사실 이 예제에서 `identity` 함수를 사용하기에는 어려움이 있습니다. `always`와 같이 사용하려면 `_confirm` 함수를 조금 바꿔줘야 합니다.\n\n#### (3) 오늘의 함수 - confirm 함수와의 콜라보 2\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { \n  var res = confirm(message); // [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.\n  return res ? yes_fn(res) : no_fn(res); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { \n    $(e.delegateTarget).remove();\n  }, identity) // [2] 항상 'false'를 반환하게 됩니다. \n})\n```\n\n`_confirm` 함수를 조금 바꿔서 `identity` 함수가 `always(false)`를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 `pipe` 함수를 통해서 보여드릴 수 있을 것 같습니다.","source":"_posts/javascript-daily-function-4.md","raw":"---\ntitle: '[오늘의 함수] identity, always'\ndate: 2017-03-20 23:41:48\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## identity, always 함수 \n\n오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 `identity`와 `always` 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.\n\n#### (1) 오늘의 함수 - identity와 always\n```javascript\nfunction identity(value) {\n  return value;\n}\n\nfunction always(value) {\n  return function() {\n    return value;\n  }\n}\n\nconsole.log(identity(10)); // 10\nconsole.log(always(10)()); // 10\n```\n\n정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 `confirm` 함수를 사용해서 예시를 만들어보겠습니다.\n\n#### (2) 오늘의 함수 - confirm 함수와의 콜라보 1\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { // [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.\n  return confirm(message) ? yes_fn() : no_fn(); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, always(false)) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.\n})\n```\n\n주목하셔야할 부분은 역시 `always` 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 `function() { return false }`로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 '_항상 false를 반환하는구나_'하고 이해가 됩니다. \n\n사실 이 예제에서 `identity` 함수를 사용하기에는 어려움이 있습니다. `always`와 같이 사용하려면 `_confirm` 함수를 조금 바꿔줘야 합니다.\n\n#### (3) 오늘의 함수 - confirm 함수와의 콜라보 2\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { \n  var res = confirm(message); // [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.\n  return res ? yes_fn(res) : no_fn(res); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { \n    $(e.delegateTarget).remove();\n  }, identity) // [2] 항상 'false'를 반환하게 됩니다. \n})\n```\n\n`_confirm` 함수를 조금 바꿔서 `identity` 함수가 `always(false)`를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 `pipe` 함수를 통해서 보여드릴 수 있을 것 같습니다.","slug":"javascript-daily-function-4","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1qv001bi3vgc72zbz2w","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"identity-always-함수\"><a href=\"#identity-always-함수\" class=\"headerlink\" title=\"identity, always 함수\"></a>identity, always 함수</h2><p>오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 <code>identity</code>와 <code>always</code> 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.</p>\n<h4 id=\"1-오늘의-함수-identity와-always\"><a href=\"#1-오늘의-함수-identity와-always\" class=\"headerlink\" title=\"(1) 오늘의 함수 - identity와 always\"></a>(1) 오늘의 함수 - identity와 always</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">always</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(identity(<span class=\"number\">10</span>)); <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(always(<span class=\"number\">10</span>)()); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 <code>confirm</code> 함수를 사용해서 예시를 만들어보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-confirm-함수와의-콜라보-1\"><a href=\"#2-오늘의-함수-confirm-함수와의-콜라보-1\" class=\"headerlink\" title=\"(2) 오늘의 함수 - confirm 함수와의 콜라보 1\"></a>(2) 오늘의 함수 - confirm 함수와의 콜라보 1</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; <span class=\"comment\">// [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, always(<span class=\"literal\">false</span>)) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>주목하셔야할 부분은 역시 <code>always</code> 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 <code>function() { return false }</code>로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 ‘<em>항상 false를 반환하는구나</em>‘하고 이해가 됩니다. </p>\n<p>사실 이 예제에서 <code>identity</code> 함수를 사용하기에는 어려움이 있습니다. <code>always</code>와 같이 사용하려면 <code>_confirm</code> 함수를 조금 바꿔줘야 합니다.</p>\n<h4 id=\"3-오늘의-함수-confirm-함수와의-콜라보-2\"><a href=\"#3-오늘의-함수-confirm-함수와의-콜라보-2\" class=\"headerlink\" title=\"(3) 오늘의 함수 - confirm 함수와의 콜라보 2\"></a>(3) 오늘의 함수 - confirm 함수와의 콜라보 2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; </div><div class=\"line\">  <span class=\"keyword\">var</span> res = confirm(message); <span class=\"comment\">// [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> res ? yes_fn(res) : no_fn(res); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, identity) <span class=\"comment\">// [2] 항상 'false'를 반환하게 됩니다. </span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>_confirm</code> 함수를 조금 바꿔서 <code>identity</code> 함수가 <code>always(false)</code>를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 <code>pipe</code> 함수를 통해서 보여드릴 수 있을 것 같습니다.</p>\n","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"identity-always-함수\"><a href=\"#identity-always-함수\" class=\"headerlink\" title=\"identity, always 함수\"></a>identity, always 함수</h2><p>오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 <code>identity</code>와 <code>always</code> 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.</p>\n<h4 id=\"1-오늘의-함수-identity와-always\"><a href=\"#1-오늘의-함수-identity와-always\" class=\"headerlink\" title=\"(1) 오늘의 함수 - identity와 always\"></a>(1) 오늘의 함수 - identity와 always</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">always</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(identity(<span class=\"number\">10</span>)); <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(always(<span class=\"number\">10</span>)()); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 <code>confirm</code> 함수를 사용해서 예시를 만들어보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-confirm-함수와의-콜라보-1\"><a href=\"#2-오늘의-함수-confirm-함수와의-콜라보-1\" class=\"headerlink\" title=\"(2) 오늘의 함수 - confirm 함수와의 콜라보 1\"></a>(2) 오늘의 함수 - confirm 함수와의 콜라보 1</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; <span class=\"comment\">// [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, always(<span class=\"literal\">false</span>)) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>주목하셔야할 부분은 역시 <code>always</code> 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 <code>function() { return false }</code>로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 ‘<em>항상 false를 반환하는구나</em>‘하고 이해가 됩니다. </p>\n<p>사실 이 예제에서 <code>identity</code> 함수를 사용하기에는 어려움이 있습니다. <code>always</code>와 같이 사용하려면 <code>_confirm</code> 함수를 조금 바꿔줘야 합니다.</p>\n<h4 id=\"3-오늘의-함수-confirm-함수와의-콜라보-2\"><a href=\"#3-오늘의-함수-confirm-함수와의-콜라보-2\" class=\"headerlink\" title=\"(3) 오늘의 함수 - confirm 함수와의 콜라보 2\"></a>(3) 오늘의 함수 - confirm 함수와의 콜라보 2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; </div><div class=\"line\">  <span class=\"keyword\">var</span> res = confirm(message); <span class=\"comment\">// [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.</span></div><div class=\"line\">  <span class=\"keyword\">return</span> res ? yes_fn(res) : no_fn(res); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">    $(e.delegateTarget).remove();</div><div class=\"line\">  &#125;, identity) <span class=\"comment\">// [2] 항상 'false'를 반환하게 됩니다. </span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><code>_confirm</code> 함수를 조금 바꿔서 <code>identity</code> 함수가 <code>always(false)</code>를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 <code>pipe</code> 함수를 통해서 보여드릴 수 있을 것 같습니다.</p>\n"},{"title":"[오늘의 함수] nest","date":"2017-03-28T14:07:24.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## nest 함수\n\n[`pick` 함수 편](http://joeun.me/2017/03/07/javascript-daily-function-2/)에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 `nest` 함수입니다.\n\n#### (1) 어제의 함수\n```javascript\n  var nested_obj = {};\n  nested_obj.first = {};\n  nested_obj.first.second = {};\n  nested_obj.first.second.third = \"I'm nested object.\";\n\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```\n\n이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 `nest` 함수는 이를 한번에 만들어줍니다.\n\n#### (2) 오늘의 함수 - 중첩 객체 만들기\n```javascript\n  var nest = function(key, value) {\n    return key.split('.').reduceRight(valkey, value); // [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.\n  };\n\n  function valkey(value, key) { // [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)\n    return { [key] : value }; // [3] ES6부터 지원하는 문법입니다. (Computed property names) \n  }\n  \n  var nested_obj = nest('first.second.third', \"I'am nested object.\");\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```","source":"_posts/javascript-daily-function-6.md","raw":"---\ntitle: '[오늘의 함수] nest'\ndate: 2017-03-28 23:07:24\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## nest 함수\n\n[`pick` 함수 편](http://joeun.me/2017/03/07/javascript-daily-function-2/)에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 `nest` 함수입니다.\n\n#### (1) 어제의 함수\n```javascript\n  var nested_obj = {};\n  nested_obj.first = {};\n  nested_obj.first.second = {};\n  nested_obj.first.second.third = \"I'm nested object.\";\n\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```\n\n이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 `nest` 함수는 이를 한번에 만들어줍니다.\n\n#### (2) 오늘의 함수 - 중첩 객체 만들기\n```javascript\n  var nest = function(key, value) {\n    return key.split('.').reduceRight(valkey, value); // [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.\n  };\n\n  function valkey(value, key) { // [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)\n    return { [key] : value }; // [3] ES6부터 지원하는 문법입니다. (Computed property names) \n  }\n  \n  var nested_obj = nest('first.second.third', \"I'am nested object.\");\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```","slug":"javascript-daily-function-6","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1r2001di3vgaeywszws","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"nest-함수\"><a href=\"#nest-함수\" class=\"headerlink\" title=\"nest 함수\"></a>nest 함수</h2><p><a href=\"http://joeun.me/2017/03/07/javascript-daily-function-2/\"><code>pick</code> 함수 편</a>에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 <code>nest</code> 함수입니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nested_obj = &#123;&#125;;</div><div class=\"line\">nested_obj.first = &#123;&#125;;</div><div class=\"line\">nested_obj.first.second = &#123;&#125;;</div><div class=\"line\">nested_obj.first.second.third = <span class=\"string\">\"I'm nested object.\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></div></pre></td></tr></table></figure>\n<p>이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 <code>nest</code> 함수는 이를 한번에 만들어줍니다.</p>\n<h4 id=\"2-오늘의-함수-중첩-객체-만들기\"><a href=\"#2-오늘의-함수-중첩-객체-만들기\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 중첩 객체 만들기\"></a>(2) 오늘의 함수 - 중첩 객체 만들기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> key.split(<span class=\"string\">'.'</span>).reduceRight(valkey, value); <span class=\"comment\">// [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valkey</span>(<span class=\"params\">value, key</span>) </span>&#123; <span class=\"comment\">// [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; [key] : value &#125;; <span class=\"comment\">// [3] ES6부터 지원하는 문법입니다. (Computed property names) </span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> nested_obj = nest(<span class=\"string\">'first.second.third'</span>, <span class=\"string\">\"I'am nested object.\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"nest-함수\"><a href=\"#nest-함수\" class=\"headerlink\" title=\"nest 함수\"></a>nest 함수</h2><p><a href=\"http://joeun.me/2017/03/07/javascript-daily-function-2/\"><code>pick</code> 함수 편</a>에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 <code>nest</code> 함수입니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nested_obj = &#123;&#125;;</div><div class=\"line\">nested_obj.first = &#123;&#125;;</div><div class=\"line\">nested_obj.first.second = &#123;&#125;;</div><div class=\"line\">nested_obj.first.second.third = <span class=\"string\">\"I'm nested object.\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></div></pre></td></tr></table></figure>\n<p>이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 <code>nest</code> 함수는 이를 한번에 만들어줍니다.</p>\n<h4 id=\"2-오늘의-함수-중첩-객체-만들기\"><a href=\"#2-오늘의-함수-중첩-객체-만들기\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 중첩 객체 만들기\"></a>(2) 오늘의 함수 - 중첩 객체 만들기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> key.split(<span class=\"string\">'.'</span>).reduceRight(valkey, value); <span class=\"comment\">// [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valkey</span>(<span class=\"params\">value, key</span>) </span>&#123; <span class=\"comment\">// [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; [key] : value &#125;; <span class=\"comment\">// [3] ES6부터 지원하는 문법입니다. (Computed property names) </span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> nested_obj = nest(<span class=\"string\">'first.second.third'</span>, <span class=\"string\">\"I'am nested object.\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></div></pre></td></tr></table></figure>"},{"title":"[오늘의 함수] partial","date":"2017-04-19T14:41:48.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial 함수\n\n함수를 만들면서 프로그래밍을 하다보면 `pipe`와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 `partial`도 그런 유형의 함수입니다. 사실 '새로운 함수'를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 __기존의 함수에 인자를 미리 적용해두는 일을 하는 함수__입니다. 내장함수 중에서 `bind`와 같은 일을 합니다. \n\n#### (1) 어제의 함수 - 인자를 미리 적용해두기\n\n```javascript\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = sum.bind(null, 10); // [1] 첫번째 인자로 넘긴 null은 this 값 입니다.\nvar sum20 = sum.bind(null, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\n내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 `partial`입니다. 우리가 원하는 '건너뛰고 적용하기'까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.\n\n\n#### (2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\n\n```javascript\nvar partial = function(func, ...args1) { // [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)\n  return function(...args2) { // [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)\n    return func(...[...args1, ...args2]); // [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\nES6에 새롭게 추가된 기능인 [Spread 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator)를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 `bind`와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.\n\n\n#### (3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar test = function(a, b, c, d) { // [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.\n  console.log(a, b, c, d);\n}\n\nvar skip = partial(test, 1, _, 3); // [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.\nskip(20, 40); // [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40\n```\n\n(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 '건너뛰기'라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 '비워두기'가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)","source":"_posts/javascript-daily-function-7.md","raw":"---\ntitle: '[오늘의 함수] partial'\ndate: 2017-04-19 23:41:48\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial 함수\n\n함수를 만들면서 프로그래밍을 하다보면 `pipe`와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 `partial`도 그런 유형의 함수입니다. 사실 '새로운 함수'를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 __기존의 함수에 인자를 미리 적용해두는 일을 하는 함수__입니다. 내장함수 중에서 `bind`와 같은 일을 합니다. \n\n#### (1) 어제의 함수 - 인자를 미리 적용해두기\n\n```javascript\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = sum.bind(null, 10); // [1] 첫번째 인자로 넘긴 null은 this 값 입니다.\nvar sum20 = sum.bind(null, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\n내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 `partial`입니다. 우리가 원하는 '건너뛰고 적용하기'까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.\n\n\n#### (2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\n\n```javascript\nvar partial = function(func, ...args1) { // [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)\n  return function(...args2) { // [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)\n    return func(...[...args1, ...args2]); // [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\nES6에 새롭게 추가된 기능인 [Spread 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator)를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 `bind`와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.\n\n\n#### (3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar test = function(a, b, c, d) { // [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.\n  console.log(a, b, c, d);\n}\n\nvar skip = partial(test, 1, _, 3); // [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.\nskip(20, 40); // [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40\n```\n\n(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 '건너뛰기'라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 '비워두기'가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)","slug":"javascript-daily-function-7","published":1,"updated":"2017-04-26T14:10:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1r5001fi3vgunfh1n2v","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial-함수\"><a href=\"#partial-함수\" class=\"headerlink\" title=\"partial 함수\"></a>partial 함수</h2><p>함수를 만들면서 프로그래밍을 하다보면 <code>pipe</code>와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 <code>partial</code>도 그런 유형의 함수입니다. 사실 ‘새로운 함수’를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 <strong>기존의 함수에 인자를 미리 적용해두는 일을 하는 함수</strong>입니다. 내장함수 중에서 <code>bind</code>와 같은 일을 합니다. </p>\n<h4 id=\"1-어제의-함수-인자를-미리-적용해두기\"><a href=\"#1-어제의-함수-인자를-미리-적용해두기\" class=\"headerlink\" title=\"(1) 어제의 함수 - 인자를 미리 적용해두기\"></a>(1) 어제의 함수 - 인자를 미리 적용해두기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>); <span class=\"comment\">// [1] 첫번째 인자로 넘긴 null은 this 값 입니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></div></pre></td></tr></table></figure>\n<p>내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 <code>partial</code>입니다. 우리가 원하는 ‘건너뛰고 적용하기’까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-1단계-bind와-같은-수준의-partial\"><a href=\"#2-오늘의-함수-1단계-bind와-같은-수준의-partial\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\"></a>(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args1</span>) </span>&#123; <span class=\"comment\">// [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123; <span class=\"comment\">// [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)</span></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]); <span class=\"comment\">// [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></div></pre></td></tr></table></figure>\n<p>ES6에 새롭게 추가된 기능인 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"external\">Spread 연산자</a>를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 <code>bind</code>와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.</p>\n<h4 id=\"3-오늘의-함수-2단계-건너뛰기가-가능한-partial\"><a href=\"#3-오늘의-함수-2단계-건너뛰기가-가능한-partial\" class=\"headerlink\" title=\"(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\"></a>(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></div><div class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123; <span class=\"comment\">// [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c, d);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> skip = partial(test, <span class=\"number\">1</span>, _, <span class=\"number\">3</span>); <span class=\"comment\">// [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.</span></div><div class=\"line\">skip(<span class=\"number\">20</span>, <span class=\"number\">40</span>); <span class=\"comment\">// [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40</span></div></pre></td></tr></table></figure>\n<p>(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 ‘건너뛰기’라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 ‘비워두기’가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)</p>\n","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial-함수\"><a href=\"#partial-함수\" class=\"headerlink\" title=\"partial 함수\"></a>partial 함수</h2><p>함수를 만들면서 프로그래밍을 하다보면 <code>pipe</code>와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 <code>partial</code>도 그런 유형의 함수입니다. 사실 ‘새로운 함수’를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 <strong>기존의 함수에 인자를 미리 적용해두는 일을 하는 함수</strong>입니다. 내장함수 중에서 <code>bind</code>와 같은 일을 합니다. </p>\n<h4 id=\"1-어제의-함수-인자를-미리-적용해두기\"><a href=\"#1-어제의-함수-인자를-미리-적용해두기\" class=\"headerlink\" title=\"(1) 어제의 함수 - 인자를 미리 적용해두기\"></a>(1) 어제의 함수 - 인자를 미리 적용해두기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>); <span class=\"comment\">// [1] 첫번째 인자로 넘긴 null은 this 값 입니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></div></pre></td></tr></table></figure>\n<p>내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 <code>partial</code>입니다. 우리가 원하는 ‘건너뛰고 적용하기’까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-1단계-bind와-같은-수준의-partial\"><a href=\"#2-오늘의-함수-1단계-bind와-같은-수준의-partial\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\"></a>(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args1</span>) </span>&#123; <span class=\"comment\">// [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123; <span class=\"comment\">// [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)</span></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]); <span class=\"comment\">// [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></div></pre></td></tr></table></figure>\n<p>ES6에 새롭게 추가된 기능인 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator\">Spread 연산자</a>를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 <code>bind</code>와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.</p>\n<h4 id=\"3-오늘의-함수-2단계-건너뛰기가-가능한-partial\"><a href=\"#3-오늘의-함수-2단계-건너뛰기가-가능한-partial\" class=\"headerlink\" title=\"(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\"></a>(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></div><div class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123; <span class=\"comment\">// [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c, d);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> skip = partial(test, <span class=\"number\">1</span>, _, <span class=\"number\">3</span>); <span class=\"comment\">// [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.</span></div><div class=\"line\">skip(<span class=\"number\">20</span>, <span class=\"number\">40</span>); <span class=\"comment\">// [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40</span></div></pre></td></tr></table></figure>\n<p>(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 ‘건너뛰기’라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 ‘비워두기’가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)</p>\n"},{"title":"[오늘의 함수] partial2","date":"2017-04-26T13:54:34.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial2 함수\n\n오늘은 지난 시간에 만든 `partial` 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 `partial2`라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.\n\n#### (1) 어제의 함수 - partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar log = partial(console.log, 0, _, 0, 0, _, 0);\nlog(1,2,3); // 0 1 0 0 2 0 3\n```\n\n이번에 기존 `partial` 함수에 아쉬운 점은 '유연함'입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 `_`는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 `partial2`입니다.\n\n\n#### (2) 오늘의 함수 - partial2\n\n```javascript\nvar partial2 = function(func, ...parts) {\n  var parts1 = [], parts2 = [], ___idx = parts.length;\n\n  for (var i in parts) {\n    if (parts[i] == ___) {\n      ___idx = i; \n    }\n    else if (i < ___idx) {\n      parts1.push(parts[i]);\n    }\n    else {\n      parts2.push(parts[i]);\n    }\n  }\n\n\n  return function(...args) {\n    var args1 = parts1.slice(), \n        args2 = parts2.slice(),\n        rest = args.slice();\n\n    for (var i in args1) {\n      if (args1[i] == _) {\n        args1[i] = rest.shift(); \n      }\n    }     \n      \n    for (var i in args2) {\n      if (args2[i] == _) {\n        args2[i] = rest.pop();\n      }\n    }\n\n    return func(...[...args1, ...rest, ...args2]);\n  }\n}\n\nvar log = partial2(console.log, 0, _, 0, ___, 0, _, 0);\nlog(1,2,3,4,5,6,7,8,9,10); // 0 1 0 2 3 4 5 6 7 8 9 0 10 0\n\nvar greeting = partial2(console.log, 'Hello,', _, ___, 'Nice to meet you.');\ngreeting('Joeun.', 'My name is', 'Momo.', '\\n', 'I\\'m', 27, 'years old.\\n'); \n/* \nHello, Joeun. \n My name is Momo. \n I'm 27 years old. \n Nice to meet you.  \n*/\n```","source":"_posts/javascript-daily-function-8.md","raw":"---\ntitle: '[오늘의 함수] partial2'\ndate: 2017-04-26 22:54:34\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial2 함수\n\n오늘은 지난 시간에 만든 `partial` 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 `partial2`라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.\n\n#### (1) 어제의 함수 - partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar log = partial(console.log, 0, _, 0, 0, _, 0);\nlog(1,2,3); // 0 1 0 0 2 0 3\n```\n\n이번에 기존 `partial` 함수에 아쉬운 점은 '유연함'입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 `_`는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 `partial2`입니다.\n\n\n#### (2) 오늘의 함수 - partial2\n\n```javascript\nvar partial2 = function(func, ...parts) {\n  var parts1 = [], parts2 = [], ___idx = parts.length;\n\n  for (var i in parts) {\n    if (parts[i] == ___) {\n      ___idx = i; \n    }\n    else if (i < ___idx) {\n      parts1.push(parts[i]);\n    }\n    else {\n      parts2.push(parts[i]);\n    }\n  }\n\n\n  return function(...args) {\n    var args1 = parts1.slice(), \n        args2 = parts2.slice(),\n        rest = args.slice();\n\n    for (var i in args1) {\n      if (args1[i] == _) {\n        args1[i] = rest.shift(); \n      }\n    }     \n      \n    for (var i in args2) {\n      if (args2[i] == _) {\n        args2[i] = rest.pop();\n      }\n    }\n\n    return func(...[...args1, ...rest, ...args2]);\n  }\n}\n\nvar log = partial2(console.log, 0, _, 0, ___, 0, _, 0);\nlog(1,2,3,4,5,6,7,8,9,10); // 0 1 0 2 3 4 5 6 7 8 9 0 10 0\n\nvar greeting = partial2(console.log, 'Hello,', _, ___, 'Nice to meet you.');\ngreeting('Joeun.', 'My name is', 'Momo.', '\\n', 'I\\'m', 27, 'years old.\\n'); \n/* \nHello, Joeun. \n My name is Momo. \n I'm 27 years old. \n Nice to meet you.  \n*/\n```","slug":"javascript-daily-function-8","published":1,"updated":"2017-04-26T14:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1r9001ji3vgu27uvibu","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial2-함수\"><a href=\"#partial2-함수\" class=\"headerlink\" title=\"partial2 함수\"></a>partial2 함수</h2><p>오늘은 지난 시간에 만든 <code>partial</code> 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 <code>partial2</code>라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-partial\"><a href=\"#1-어제의-함수-partial\" class=\"headerlink\" title=\"(1) 어제의 함수 - partial\"></a>(1) 어제의 함수 - partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></div><div class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> log = partial(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</div><div class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 0 1 0 0 2 0 3</span></div></pre></td></tr></table></figure>\n<p>이번에 기존 <code>partial</code> 함수에 아쉬운 점은 ‘유연함’입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 <code>_</code>는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 <code>partial2</code>입니다.</p>\n<h4 id=\"2-오늘의-함수-partial2\"><a href=\"#2-오늘의-함수-partial2\" class=\"headerlink\" title=\"(2) 오늘의 함수 - partial2\"></a>(2) 오늘의 함수 - partial2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> partial2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...parts</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> parts1 = [], parts2 = [], ___idx = parts.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> parts) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (parts[i] == ___) &#123;</div><div class=\"line\">      ___idx = i; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; ___idx) &#123;</div><div class=\"line\">      parts1.push(parts[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      parts2.push(parts[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = parts1.slice(), </div><div class=\"line\">        args2 = parts2.slice(),</div><div class=\"line\">        rest = args.slice();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] == _) &#123;</div><div class=\"line\">        args1[i] = rest.shift(); </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;     </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args2) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (args2[i] == _) &#123;</div><div class=\"line\">        args2[i] = rest.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...rest, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> log = partial2(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, ___, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</div><div class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>); <span class=\"comment\">// 0 1 0 2 3 4 5 6 7 8 9 0 10 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> greeting = partial2(<span class=\"built_in\">console</span>.log, <span class=\"string\">'Hello,'</span>, _, ___, <span class=\"string\">'Nice to meet you.'</span>);</div><div class=\"line\">greeting(<span class=\"string\">'Joeun.'</span>, <span class=\"string\">'My name is'</span>, <span class=\"string\">'Momo.'</span>, <span class=\"string\">'\\n'</span>, <span class=\"string\">'I\\'m'</span>, <span class=\"number\">27</span>, <span class=\"string\">'years old.\\n'</span>); </div><div class=\"line\"><span class=\"comment\">/* </span></div><div class=\"line\">Hello, Joeun. </div><div class=\"line\"> My name is Momo. </div><div class=\"line\"> I'm 27 years old. </div><div class=\"line\"> Nice to meet you.  </div><div class=\"line\">*/</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial2-함수\"><a href=\"#partial2-함수\" class=\"headerlink\" title=\"partial2 함수\"></a>partial2 함수</h2><p>오늘은 지난 시간에 만든 <code>partial</code> 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 <code>partial2</code>라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-partial\"><a href=\"#1-어제의-함수-partial\" class=\"headerlink\" title=\"(1) 어제의 함수 - partial\"></a>(1) 어제의 함수 - partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></div><div class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></div><div class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</div><div class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></div><div class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> log = partial(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</div><div class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 0 1 0 0 2 0 3</span></div></pre></td></tr></table></figure>\n<p>이번에 기존 <code>partial</code> 함수에 아쉬운 점은 ‘유연함’입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 <code>_</code>는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 <code>partial2</code>입니다.</p>\n<h4 id=\"2-오늘의-함수-partial2\"><a href=\"#2-오늘의-함수-partial2\" class=\"headerlink\" title=\"(2) 오늘의 함수 - partial2\"></a>(2) 오늘의 함수 - partial2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> partial2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...parts</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> parts1 = [], parts2 = [], ___idx = parts.length;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> parts) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (parts[i] == ___) &#123;</div><div class=\"line\">      ___idx = i; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; ___idx) &#123;</div><div class=\"line\">      parts1.push(parts[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      parts2.push(parts[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args1 = parts1.slice(), </div><div class=\"line\">        args2 = parts2.slice(),</div><div class=\"line\">        rest = args.slice();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (args1[i] == _) &#123;</div><div class=\"line\">        args1[i] = rest.shift(); </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;     </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args2) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (args2[i] == _) &#123;</div><div class=\"line\">        args2[i] = rest.pop();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...rest, ...args2]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> log = partial2(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, ___, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</div><div class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>); <span class=\"comment\">// 0 1 0 2 3 4 5 6 7 8 9 0 10 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> greeting = partial2(<span class=\"built_in\">console</span>.log, <span class=\"string\">'Hello,'</span>, _, ___, <span class=\"string\">'Nice to meet you.'</span>);</div><div class=\"line\">greeting(<span class=\"string\">'Joeun.'</span>, <span class=\"string\">'My name is'</span>, <span class=\"string\">'Momo.'</span>, <span class=\"string\">'\\n'</span>, <span class=\"string\">'I\\'m'</span>, <span class=\"number\">27</span>, <span class=\"string\">'years old.\\n'</span>); </div><div class=\"line\"><span class=\"comment\">/* </div><div class=\"line\">Hello, Joeun. </div><div class=\"line\"> My name is Momo. </div><div class=\"line\"> I'm 27 years old. </div><div class=\"line\"> Nice to meet you.  </div><div class=\"line\">*/</span></div></pre></td></tr></table></figure>"},{"title":"[오늘의 함수] redirect","date":"2017-03-02T06:11:12.000Z","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect 함수\n\n서버로 데이터를 보내거나 요청할 때 __별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우__가 종종 있습니다. 아래의 1번 방법과 같이 `$.post`를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.\n    if (res) {\n      return window.location.href = '/main/newsfeed';\n    } else {\n      console.error('return data:', res);\n    }\n  });\n```\n\n때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 `redirect` 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect('/main/newsfeed')); // [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. \n\n$.post('/api/post/update', data)\n  .done(redirect('/main/editor')); // [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.\n\n$.post('/api/post/delete', data)\n  .done(redirect('/main/home'));\n```","source":"_posts/javascript-daily-function.md","raw":"---\ntitle: '[오늘의 함수] redirect'\ndate: 2017-03-02 15:11:12\ncategories:\n  - joeun.me\n  - programming\ntags:\n  - javascript\n  - 오늘의함수\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect 함수\n\n서버로 데이터를 보내거나 요청할 때 __별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우__가 종종 있습니다. 아래의 1번 방법과 같이 `$.post`를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.\n    if (res) {\n      return window.location.href = '/main/newsfeed';\n    } else {\n      console.error('return data:', res);\n    }\n  });\n```\n\n때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 `redirect` 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect('/main/newsfeed')); // [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. \n\n$.post('/api/post/update', data)\n  .done(redirect('/main/editor')); // [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.\n\n$.post('/api/post/delete', data)\n  .done(redirect('/main/home'));\n```","slug":"javascript-daily-function","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1rd001mi3vgfba7jvcl","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect-함수\"><a href=\"#redirect-함수\" class=\"headerlink\" title=\"redirect 함수\"></a>redirect 함수</h2><p>서버로 데이터를 보내거나 요청할 때 <strong>별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우</strong>가 종종 있습니다. 아래의 1번 방법과 같이 <code>$.post</code>를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"string\">'/main/newsfeed'</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 <code>redirect</code> 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/newsfeed'</span>)); <span class=\"comment\">// [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. </span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/editor'</span>)); <span class=\"comment\">// [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.</span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/home'</span>));</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect-함수\"><a href=\"#redirect-함수\" class=\"headerlink\" title=\"redirect 함수\"></a>redirect 함수</h2><p>서버로 데이터를 보내거나 요청할 때 <strong>별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우</strong>가 종종 있습니다. 아래의 1번 방법과 같이 <code>$.post</code>를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"string\">'/main/newsfeed'</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 <code>redirect</code> 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> redirect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/newsfeed'</span>)); <span class=\"comment\">// [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. </span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/editor'</span>)); <span class=\"comment\">// [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.</span></div><div class=\"line\"></div><div class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</div><div class=\"line\">  .done(redirect(<span class=\"string\">'/main/home'</span>));</div></pre></td></tr></table></figure>"},{"id":"15","title":"자바스크립트를 선택한 이유","date":"2015-07-17T12:10:11.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=15","geo_public":[0],"_content":"<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br /> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>","source":"_posts/javascript-intro-1.md","raw":"---\nid: 15\ntitle: 자바스크립트를 선택한 이유\ndate: 2015-07-17T21:10:11+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=15\npermalink: /javascript-intro-1/\ngeo_public:\n  - 0\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - javascript\n---\n<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br /> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>","slug":"/javascript-intro-1/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1ri001qi3vgam2sjyfk","content":"<p style=\"text-align:left;\"><br>  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>프로그래밍 경험</strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&amp;하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>왜 자바스크립트를 선택했나? </strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>필요해서 배운다!<br> </strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.<br></p>","excerpt":"","more":"<p style=\"text-align:left;\"><br>  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>프로그래밍 경험</strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&amp;하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>왜 자바스크립트를 선택했나? </strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.<br></p>\n\n<p style=\"text-align:left;\"><br>  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.<br></p>\n\n<h4 style=\"text-align:left;\"><br>  <strong>필요해서 배운다!<br /> </strong><br></h4>\n\n<p style=\"text-align:left;\"><br>  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.<br></p>"},{"id":"87","title":"자바스크립트의 예약어","date":"2015-08-31T22:30:00.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=87","_content":"다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.\n\n모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.\n\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.","source":"_posts/javascript-keywords.md","raw":"---\nid: 87\ntitle: 자바스크립트의 예약어\ndate: 2015-09-01T07:30:00+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=87\npermalink: /javascript-keyword/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - javascript\n---\n다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.\n\n모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.\n\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.","slug":"/javascript-keyword/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1ro001ti3vggv325b8h","content":"<p>다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.</p>\n<p>모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.</p>\n<p style=\"padding-left:30px;\"><br>  A &#8211; abstract<br></p>\n\n<p style=\"padding-left:30px;\"><br>  B &#8211; boolean, break, byte<br></p>\n\n<p style=\"padding-left:30px;\"><br>  C &#8211; case, catch, char, class, const, continue<br></p>\n\n<p style=\"padding-left:30px;\"><br>  D &#8211; debugger, default, delete, do, double<br></p>\n\n<p style=\"padding-left:30px;\"><br>  E &#8211; else, enum, export, extends<br></p>\n\n<p style=\"padding-left:30px;\"><br>  F &#8211; false, final, finally, float, for, function<br></p>\n\n<p style=\"padding-left:30px;\"><br>  G &#8211; goto<br></p>\n\n<p style=\"padding-left:30px;\"><br>  I &#8211; if, implements, import, in, instanceof, int, interface<br></p>\n\n<p style=\"padding-left:30px;\"><br>  L &#8211; long<br></p>\n\n<p style=\"padding-left:30px;\"><br>  N &#8211; native, new, null<br></p>\n\n<p style=\"padding-left:30px;\"><br>  P &#8211; package, private, protected, public<br></p>\n\n<p style=\"padding-left:30px;\"><br>  R &#8211; return<br></p>\n\n<p style=\"padding-left:30px;\"><br>  S &#8211; short, static, super, switch, synchronized<br></p>\n\n<p style=\"padding-left:30px;\"><br>  T &#8211; this, throw, throws, transient, true, try, typeof<br></p>\n\n<p style=\"padding-left:30px;\"><br>  V &#8211; var, volatile, void<br></p>\n\n<p style=\"padding-left:30px;\"><br>  W &#8211; while, with<br></p>\n\n<p>이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.</p>\n","excerpt":"","more":"<p>다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.</p>\n<p>모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.</p>\n<p style=\"padding-left:30px;\"><br>  A &#8211; abstract<br></p>\n\n<p style=\"padding-left:30px;\"><br>  B &#8211; boolean, break, byte<br></p>\n\n<p style=\"padding-left:30px;\"><br>  C &#8211; case, catch, char, class, const, continue<br></p>\n\n<p style=\"padding-left:30px;\"><br>  D &#8211; debugger, default, delete, do, double<br></p>\n\n<p style=\"padding-left:30px;\"><br>  E &#8211; else, enum, export, extends<br></p>\n\n<p style=\"padding-left:30px;\"><br>  F &#8211; false, final, finally, float, for, function<br></p>\n\n<p style=\"padding-left:30px;\"><br>  G &#8211; goto<br></p>\n\n<p style=\"padding-left:30px;\"><br>  I &#8211; if, implements, import, in, instanceof, int, interface<br></p>\n\n<p style=\"padding-left:30px;\"><br>  L &#8211; long<br></p>\n\n<p style=\"padding-left:30px;\"><br>  N &#8211; native, new, null<br></p>\n\n<p style=\"padding-left:30px;\"><br>  P &#8211; package, private, protected, public<br></p>\n\n<p style=\"padding-left:30px;\"><br>  R &#8211; return<br></p>\n\n<p style=\"padding-left:30px;\"><br>  S &#8211; short, static, super, switch, synchronized<br></p>\n\n<p style=\"padding-left:30px;\"><br>  T &#8211; this, throw, throws, transient, true, try, typeof<br></p>\n\n<p style=\"padding-left:30px;\"><br>  V &#8211; var, volatile, void<br></p>\n\n<p style=\"padding-left:30px;\"><br>  W &#8211; while, with<br></p>\n\n<p>이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.</p>\n"},{"id":"484","title":"프로토타입","date":"2016-03-29T15:26:18.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=484","_content":"오늘은 &#8216;**prototype(프로토타입)**&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? \n\n이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.\n\n그럼 이런 경우는 어떨까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)\n\n이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 `var o = Sun.prototype`라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?\n\n&#8220;_객체는 결코 복사되지 않는다. 다만 참조된다._&#8221; 바로 이 문장 때문입니다.\n  \n그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.","source":"_posts/javascript-prototype.md","raw":"---\nid: 484\ntitle: 프로토타입\ndate: 2016-03-30T00:26:18+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=484\npermalink: /javascript-prototype/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - javascript\n---\n오늘은 &#8216;**prototype(프로토타입)**&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? \n\n이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.\n\n그럼 이런 경우는 어떨까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)\n\n이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 `var o = Sun.prototype`라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?\n\n&#8220;_객체는 결코 복사되지 않는다. 다만 참조된다._&#8221; 바로 이 문장 때문입니다.\n  \n그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.","slug":"/javascript-prototype/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1rs001xi3vgj939idha","content":"<p>오늘은 &#8216;<strong>prototype(프로토타입)</strong>&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? </p>\n<p>이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.</p>\n<p>그럼 이런 경우는 어떨까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)</p>\n<p>이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 <code>var o = Sun.prototype</code>라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?</p>\n<p>&#8220;<em>객체는 결코 복사되지 않는다. 다만 참조된다.</em>&#8221; 바로 이 문장 때문입니다.</p>\n<p>그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n<p>이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.</p>\n","excerpt":"","more":"<p>오늘은 &#8216;<strong>prototype(프로토타입)</strong>&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? </p>\n<p>이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.</p>\n<p>그럼 이런 경우는 어떨까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)</p>\n<p>이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 <code>var o = Sun.prototype</code>라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?</p>\n<p>&#8220;<em>객체는 결코 복사되지 않는다. 다만 참조된다.</em>&#8221; 바로 이 문장 때문입니다.</p>\n<p>그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n<p>이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.</p>\n"},{"id":"47","title":"자바스크립트, 어떻게 공부하지?","date":"2015-07-21T13:39:27.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=47","geo_public":[0],"_content":"어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.\n\n#### **훌륭한 스승을 찾아서**\n\n훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.\n\n정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.\n\n해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.\n\n책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\">\n\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n#### **이제 훌륭한 제자가 되자!**\n\n위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.","source":"_posts/javasrcipt-intro-2.md","raw":"---\nid: 47\ntitle: 자바스크립트, 어떻게 공부하지?\ndate: 2015-07-21T22:39:27+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=47\npermalink: /javasrcipt-intro-2/\ngeo_public:\n  - 0\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - javascript\n---\n어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.\n\n#### **훌륭한 스승을 찾아서**\n\n훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.\n\n정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.\n\n해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.\n\n책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\">\n\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n#### **이제 훌륭한 제자가 되자!**\n\n위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.","slug":"/javasrcipt-intro-2/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1rz0020i3vg0twwiism","content":"<p>어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.</p>\n<h4 id=\"훌륭한-스승을-찾아서\"><a href=\"#훌륭한-스승을-찾아서\" class=\"headerlink\" title=\"훌륭한 스승을 찾아서\"></a><strong>훌륭한 스승을 찾아서</strong></h4><p>훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.</p>\n<p>정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.</p>\n<p>해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.</p>\n<p>책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\"></figure></p>\n<div><br><img src=\"/images/nicholas-zakas.jpg\" alt=\"\"><br><figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption><br></div><br><div><br><img src=\"/images/douglas-crockford.jpg\" alt=\"\"><br><figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption><br></div>\n\n<h4 id=\"이제-훌륭한-제자가-되자\"><a href=\"#이제-훌륭한-제자가-되자\" class=\"headerlink\" title=\"이제 훌륭한 제자가 되자!\"></a><strong>이제 훌륭한 제자가 되자!</strong></h4><p>위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.</p>\n","excerpt":"","more":"<p>어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.</p>\n<h4 id=\"훌륭한-스승을-찾아서\"><a href=\"#훌륭한-스승을-찾아서\" class=\"headerlink\" title=\"훌륭한 스승을 찾아서\"></a><strong>훌륭한 스승을 찾아서</strong></h4><p>훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.</p>\n<p>정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.</p>\n<p>해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.</p>\n<p>책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\"></p>\n<div><br><img src=\"/images/nicholas-zakas.jpg\" alt=\"\"><br><figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption><br></div><br><div><br><img src=\"/images/douglas-crockford.jpg\" alt=\"\"><br><figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption><br></div>\n\n<h4 id=\"이제-훌륭한-제자가-되자\"><a href=\"#이제-훌륭한-제자가-되자\" class=\"headerlink\" title=\"이제 훌륭한 제자가 되자!\"></a><strong>이제 훌륭한 제자가 되자!</strong></h4><p>위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.</p>\n"},{"id":"402","title":"Learn about MEAN stack","date":"2016-02-25T06:42:11.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=402","_content":"자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.\n\n책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\"><풀스택 개발자를 위한 MEAN 스택 입문></a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)\n\n지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.\n\n<a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a>\n\n&nbsp;\n\n다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.","source":"_posts/learn-about-mean-stack.md","raw":"---\nid: 402\ntitle: Learn about MEAN stack\ndate: 2016-02-25T15:42:11+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=402\npermalink: /learn-about-mean-stack/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - javascript\n---\n자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.\n\n책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\"><풀스택 개발자를 위한 MEAN 스택 입문></a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)\n\n지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.\n\n<a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a>\n\n&nbsp;\n\n다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.","slug":"/learn-about-mean-stack/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1s20024i3vg1noqekrp","content":"<p>자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.</p>\n<p>책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\">&lt;풀스택 개발자를 위한 MEAN 스택 입문&gt;</a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)</p>\n<p>지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.</p>\n<p><a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a></p>\n<p>&nbsp;</p>\n<p>다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.</p>\n","excerpt":"","more":"<p>자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.</p>\n<p>책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\">&lt;풀스택 개발자를 위한 MEAN 스택 입문&gt;</a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)</p>\n<p>지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.</p>\n<p><a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a></p>\n<p>&nbsp;</p>\n<p>다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.</p>\n"},{"title":"[나와 같다면] 직장이 아니라 직업","date":"2017-04-05T14:11:26.000Z","_content":"##### [나와 같다면] 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 직장이 아니라 직업\n\n\n#### 나의 선택\n나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.\n\n\n#### 새로운 시대\n우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.\n정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.\n\n\n#### 주도성과 창의력\n직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.\n직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.\n\n\n#### 업계(業界)\n같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.\n업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.\n\n자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.\n\n\n#### 고통의 길\n사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.\n\n\n#### 나와 같다면\n사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.\n남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.","source":"_posts/like-me-1.md","raw":"---\ntitle: '[나와 같다면] 직장이 아니라 직업'\ndate: 2017-04-05 23:11:26\ncategories:\n  - joeun.me\n  - view of value\ntags:\n  - opinion\n  - 나와같다면\n---\n##### [나와 같다면] 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 직장이 아니라 직업\n\n\n#### 나의 선택\n나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.\n\n\n#### 새로운 시대\n우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.\n정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.\n\n\n#### 주도성과 창의력\n직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.\n직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.\n\n\n#### 업계(業界)\n같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.\n업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.\n\n자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.\n\n\n#### 고통의 길\n사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.\n\n\n#### 나와 같다면\n사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.\n남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.","slug":"like-me-1","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj33ux1s50027i3vg28ms48qj","content":"<h5 id=\"나와-같다면-시리즈-소개\"><a href=\"#나와-같다면-시리즈-소개\" class=\"headerlink\" title=\"[나와 같다면] 시리즈 소개\"></a>[나와 같다면] 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"직장이-아니라-직업\"><a href=\"#직장이-아니라-직업\" class=\"headerlink\" title=\"직장이 아니라 직업\"></a>직장이 아니라 직업</h2><h4 id=\"나의-선택\"><a href=\"#나의-선택\" class=\"headerlink\" title=\"나의 선택\"></a>나의 선택</h4><p>나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.</p>\n<h4 id=\"새로운-시대\"><a href=\"#새로운-시대\" class=\"headerlink\" title=\"새로운 시대\"></a>새로운 시대</h4><p>우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.<br>정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.</p>\n<h4 id=\"주도성과-창의력\"><a href=\"#주도성과-창의력\" class=\"headerlink\" title=\"주도성과 창의력\"></a>주도성과 창의력</h4><p>직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.<br>직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.</p>\n<h4 id=\"업계-業界\"><a href=\"#업계-業界\" class=\"headerlink\" title=\"업계(業界)\"></a>업계(業界)</h4><p>같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.<br>업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.</p>\n<p>자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.</p>\n<h4 id=\"고통의-길\"><a href=\"#고통의-길\" class=\"headerlink\" title=\"고통의 길\"></a>고통의 길</h4><p>사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.</p>\n<h4 id=\"나와-같다면\"><a href=\"#나와-같다면\" class=\"headerlink\" title=\"나와 같다면\"></a>나와 같다면</h4><p>사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.<br>남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.</p>\n","excerpt":"","more":"<h5 id=\"나와-같다면-시리즈-소개\"><a href=\"#나와-같다면-시리즈-소개\" class=\"headerlink\" title=\"[나와 같다면] 시리즈 소개\"></a>[나와 같다면] 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"직장이-아니라-직업\"><a href=\"#직장이-아니라-직업\" class=\"headerlink\" title=\"직장이 아니라 직업\"></a>직장이 아니라 직업</h2><h4 id=\"나의-선택\"><a href=\"#나의-선택\" class=\"headerlink\" title=\"나의 선택\"></a>나의 선택</h4><p>나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.</p>\n<h4 id=\"새로운-시대\"><a href=\"#새로운-시대\" class=\"headerlink\" title=\"새로운 시대\"></a>새로운 시대</h4><p>우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.<br>정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.</p>\n<h4 id=\"주도성과-창의력\"><a href=\"#주도성과-창의력\" class=\"headerlink\" title=\"주도성과 창의력\"></a>주도성과 창의력</h4><p>직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.<br>직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.</p>\n<h4 id=\"업계-業界\"><a href=\"#업계-業界\" class=\"headerlink\" title=\"업계(業界)\"></a>업계(業界)</h4><p>같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.<br>업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.</p>\n<p>자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.</p>\n<h4 id=\"고통의-길\"><a href=\"#고통의-길\" class=\"headerlink\" title=\"고통의 길\"></a>고통의 길</h4><p>사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.</p>\n<h4 id=\"나와-같다면\"><a href=\"#나와-같다면\" class=\"headerlink\" title=\"나와 같다면\"></a>나와 같다면</h4><p>사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.<br>남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.</p>\n"},{"id":"488","title":"[Practice] 동물 쉼터(Animal Shelter)를 구현하라!","date":"2016-04-01T15:16:46.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=488","_content":"###### Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.\n\n* * *\n\n**코딩인터뷰 완전분석 – 연습문제 3.7**\n\n**“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”**\n\n이번부터는 자바로 구현하겠습니다. [이전 글](http://rabbylab.xyz/practice-1/)에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.\n\n코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 &#8216;먼저 들어온 동물이 먼저 나가는&#8217; 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 &#8216;LinkedList&#8217;를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">private Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n\tprivate String name;\n\tprivate int id;\n\tprivate Node next;\n\tpublic Node(String animal, int num){\n\t\tthis.name = animal;\n\t\tthis.id = num;\n\t\tthis.next = null;\n\t}\n}\n</pre>\n\n링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 &#8216;가르키는 값&#8217;이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void enqueue(String animal, int num){\n\tNode newNode = new Node(animal, num);\n\tif(size == 0){\n\t\ttail = head = newNode;\n\t} else{\n\t\thead.next = newNode;\n\t\thead = newNode;\n\t}\n\tsize++;\n}\n</pre>\n\n이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueAny(){\n\tSystem.out.println(tail.name);\n\ttail = tail.next;\n\tsize--;\n\treturn;\n}\n</pre>\n\n새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueDog(){\n\tNode chaser_1 = tail;\n\tNode chaser_2 = tail;\n\twhile(chaser_1.id != 0 && chaser_1.next != null){\n\t\tchaser_2 = chaser_1;\n\t\tchaser_1 = chaser_2.next;\n\t}\n        //개가 첫번째 노드에 있었던 경우\n\tif(chaser_1 == tail){\n\t\tdequeueAny();\n        //개를 발견한 경우\n\t} else if(chaser_1.id == 0){\n\t\tSystem.out.println(chaser_1.name + \", Bye!\\n\");\n\t\tchaser_2.next = chaser_1.next;\n\t//개가 없는 경우\n        } else{\n\t\tSystem.out.println(\"No Dog...\");\n\t\treturn;\n\t}\n\tsize--;\n\treturn;\n}\n</pre>\n\n이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser\\_1,chaser\\_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.\n  \nwhile문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser\\_2가 chaser\\_1의 위치로 갑니다. 그리고 다음 줄에서 chaser\\_1은 다음 노드로 이동합니다. 이렇게 chaser\\_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.\n  \n만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser\\_2의 다음 노드였던 chaser\\_1의 노드를 없애주기 위해 chaser\\_1 다음의 노드와 chaser\\_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.\n\ndequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tLinkedList animals = new LinkedList();\n\t\t\n\t\tanimals.enqueue(\"귀욤\",1);\n\t\tanimals.enqueue(\"개똥\",0);\n\t\tanimals.enqueue(\"황묘\",1);\n\t\tanimals.enqueue(\"백구\",0);\n\t\t\n\t\tSystem.out.println(animals);\n\t\t\n\t\tanimals.dequeueDog();\n\t\n\t\tSystem.out.println(animals);\n\t}\n\n}\n</pre>\n\n예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.\n  \n![](/images/aniqueue-result.jpg)\n\n전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.","source":"_posts/practice-animal-shelter.md","raw":"---\nid: 488\ntitle: '[Practice] 동물 쉼터(Animal Shelter)를 구현하라!'\ndate: 2016-04-02T00:16:46+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=488\npermalink: /practice-animal-shelter/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - practice\n---\n###### Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.\n\n* * *\n\n**코딩인터뷰 완전분석 – 연습문제 3.7**\n\n**“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”**\n\n이번부터는 자바로 구현하겠습니다. [이전 글](http://rabbylab.xyz/practice-1/)에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.\n\n코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 &#8216;먼저 들어온 동물이 먼저 나가는&#8217; 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 &#8216;LinkedList&#8217;를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">private Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n\tprivate String name;\n\tprivate int id;\n\tprivate Node next;\n\tpublic Node(String animal, int num){\n\t\tthis.name = animal;\n\t\tthis.id = num;\n\t\tthis.next = null;\n\t}\n}\n</pre>\n\n링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 &#8216;가르키는 값&#8217;이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void enqueue(String animal, int num){\n\tNode newNode = new Node(animal, num);\n\tif(size == 0){\n\t\ttail = head = newNode;\n\t} else{\n\t\thead.next = newNode;\n\t\thead = newNode;\n\t}\n\tsize++;\n}\n</pre>\n\n이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueAny(){\n\tSystem.out.println(tail.name);\n\ttail = tail.next;\n\tsize--;\n\treturn;\n}\n</pre>\n\n새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueDog(){\n\tNode chaser_1 = tail;\n\tNode chaser_2 = tail;\n\twhile(chaser_1.id != 0 && chaser_1.next != null){\n\t\tchaser_2 = chaser_1;\n\t\tchaser_1 = chaser_2.next;\n\t}\n        //개가 첫번째 노드에 있었던 경우\n\tif(chaser_1 == tail){\n\t\tdequeueAny();\n        //개를 발견한 경우\n\t} else if(chaser_1.id == 0){\n\t\tSystem.out.println(chaser_1.name + \", Bye!\\n\");\n\t\tchaser_2.next = chaser_1.next;\n\t//개가 없는 경우\n        } else{\n\t\tSystem.out.println(\"No Dog...\");\n\t\treturn;\n\t}\n\tsize--;\n\treturn;\n}\n</pre>\n\n이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser\\_1,chaser\\_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.\n  \nwhile문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser\\_2가 chaser\\_1의 위치로 갑니다. 그리고 다음 줄에서 chaser\\_1은 다음 노드로 이동합니다. 이렇게 chaser\\_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.\n  \n만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser\\_2의 다음 노드였던 chaser\\_1의 노드를 없애주기 위해 chaser\\_1 다음의 노드와 chaser\\_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.\n\ndequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tLinkedList animals = new LinkedList();\n\t\t\n\t\tanimals.enqueue(\"귀욤\",1);\n\t\tanimals.enqueue(\"개똥\",0);\n\t\tanimals.enqueue(\"황묘\",1);\n\t\tanimals.enqueue(\"백구\",0);\n\t\t\n\t\tSystem.out.println(animals);\n\t\t\n\t\tanimals.dequeueDog();\n\t\n\t\tSystem.out.println(animals);\n\t}\n\n}\n</pre>\n\n예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.\n  \n![](/images/aniqueue-result.jpg)\n\n전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.","slug":"/practice-animal-shelter/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1sa002bi3vgodto00h0","content":"<h6 id=\"Practice-시리즈를-연재합니다-지난-3월-3일부터-COIN-코딩인터뷰-준비하는-모임-이라는-이름으로-함께-취업스터디를-진행하고-있는-5명의-친구들과-함께-교재-lt-코딩인터뷰-완전분석-gt-이라는-책을-가지고-공부를-시작했습니다-Practice-시리즈는-이-과정에서-함께-고민하며-풀었던-문제에-대해-이야기하는-시리즈입니다\"><a href=\"#Practice-시리즈를-연재합니다-지난-3월-3일부터-COIN-코딩인터뷰-준비하는-모임-이라는-이름으로-함께-취업스터디를-진행하고-있는-5명의-친구들과-함께-교재-lt-코딩인터뷰-완전분석-gt-이라는-책을-가지고-공부를-시작했습니다-Practice-시리즈는-이-과정에서-함께-고민하며-풀었던-문제에-대해-이야기하는-시리즈입니다\" class=\"headerlink\" title=\"Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.\"></a>Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</h6><hr>\n<p><strong>코딩인터뷰 완전분석 – 연습문제 3.7</strong></p>\n<p><strong>“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”</strong></p>\n<p>이번부터는 자바로 구현하겠습니다. <a href=\"http://rabbylab.xyz/practice-1/\" target=\"_blank\" rel=\"external\">이전 글</a>에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.</p>\n<p>코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 &#8216;먼저 들어온 동물이 먼저 나가는&#8217; 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 &#8216;LinkedList&#8217;를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">private Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n    private String name;\n    private int id;\n    private Node next;\n    public Node(String animal, int num){\n        this.name = animal;\n        this.id = num;\n        this.next = null;\n    }\n}\n</pre>\n\n<p>링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 &#8216;가르키는 값&#8217;이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void enqueue(String animal, int num){\n    Node newNode = new Node(animal, num);\n    if(size == 0){\n        tail = head = newNode;\n    } else{\n        head.next = newNode;\n        head = newNode;\n    }\n    size++;\n}\n</pre>\n\n<p>이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueAny(){\n    System.out.println(tail.name);\n    tail = tail.next;\n    size--;\n    return;\n}\n</pre>\n\n<p>새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueDog(){\n    Node chaser_1 = tail;\n    Node chaser_2 = tail;\n    while(chaser_1.id != 0 && chaser_1.next != null){\n        chaser_2 = chaser_1;\n        chaser_1 = chaser_2.next;\n    }\n        //개가 첫번째 노드에 있었던 경우\n    if(chaser_1 == tail){\n        dequeueAny();\n        //개를 발견한 경우\n    } else if(chaser_1.id == 0){\n        System.out.println(chaser_1.name + \", Bye!\\n\");\n        chaser_2.next = chaser_1.next;\n    //개가 없는 경우\n        } else{\n        System.out.println(\"No Dog...\");\n        return;\n    }\n    size--;\n    return;\n}\n</pre>\n\n<p>이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser_1,chaser_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.</p>\n<p>while문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser_2가 chaser_1의 위치로 갑니다. 그리고 다음 줄에서 chaser_1은 다음 노드로 이동합니다. 이렇게 chaser_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.</p>\n<p>만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser_2의 다음 노드였던 chaser_1의 노드를 없애주기 위해 chaser_1 다음의 노드와 chaser_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.</p>\n<p>dequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public class Main {\n\n    public static void main(String[] args) {\n        LinkedList animals = new LinkedList();\n\n        animals.enqueue(\"귀욤\",1);\n        animals.enqueue(\"개똥\",0);\n        animals.enqueue(\"황묘\",1);\n        animals.enqueue(\"백구\",0);\n\n        System.out.println(animals);\n\n        animals.dequeueDog();\n\n        System.out.println(animals);\n    }\n\n}\n</pre>\n\n<p>예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.</p>\n<p><img src=\"/images/aniqueue-result.jpg\" alt=\"\"></p>\n<p>전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.</p>\n","excerpt":"","more":"<h6 id=\"Practice-시리즈를-연재합니다-지난-3월-3일부터-COIN-코딩인터뷰-준비하는-모임-이라는-이름으로-함께-취업스터디를-진행하고-있는-5명의-친구들과-함께-교재-lt-코딩인터뷰-완전분석-gt-이라는-책을-가지고-공부를-시작했습니다-Practice-시리즈는-이-과정에서-함께-고민하며-풀었던-문제에-대해-이야기하는-시리즈입니다\"><a href=\"#Practice-시리즈를-연재합니다-지난-3월-3일부터-COIN-코딩인터뷰-준비하는-모임-이라는-이름으로-함께-취업스터디를-진행하고-있는-5명의-친구들과-함께-교재-lt-코딩인터뷰-완전분석-gt-이라는-책을-가지고-공부를-시작했습니다-Practice-시리즈는-이-과정에서-함께-고민하며-풀었던-문제에-대해-이야기하는-시리즈입니다\" class=\"headerlink\" title=\"Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.\"></a>Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</h6><hr>\n<p><strong>코딩인터뷰 완전분석 – 연습문제 3.7</strong></p>\n<p><strong>“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”</strong></p>\n<p>이번부터는 자바로 구현하겠습니다. <a href=\"http://rabbylab.xyz/practice-1/\">이전 글</a>에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.</p>\n<p>코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 &#8216;먼저 들어온 동물이 먼저 나가는&#8217; 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 &#8216;LinkedList&#8217;를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">private Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n    private String name;\n    private int id;\n    private Node next;\n    public Node(String animal, int num){\n        this.name = animal;\n        this.id = num;\n        this.next = null;\n    }\n}\n</pre>\n\n<p>링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 &#8216;가르키는 값&#8217;이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void enqueue(String animal, int num){\n    Node newNode = new Node(animal, num);\n    if(size == 0){\n        tail = head = newNode;\n    } else{\n        head.next = newNode;\n        head = newNode;\n    }\n    size++;\n}\n</pre>\n\n<p>이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueAny(){\n    System.out.println(tail.name);\n    tail = tail.next;\n    size--;\n    return;\n}\n</pre>\n\n<p>새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public void dequeueDog(){\n    Node chaser_1 = tail;\n    Node chaser_2 = tail;\n    while(chaser_1.id != 0 && chaser_1.next != null){\n        chaser_2 = chaser_1;\n        chaser_1 = chaser_2.next;\n    }\n        //개가 첫번째 노드에 있었던 경우\n    if(chaser_1 == tail){\n        dequeueAny();\n        //개를 발견한 경우\n    } else if(chaser_1.id == 0){\n        System.out.println(chaser_1.name + \", Bye!\\n\");\n        chaser_2.next = chaser_1.next;\n    //개가 없는 경우\n        } else{\n        System.out.println(\"No Dog...\");\n        return;\n    }\n    size--;\n    return;\n}\n</pre>\n\n<p>이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser_1,chaser_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.</p>\n<p>while문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser_2가 chaser_1의 위치로 갑니다. 그리고 다음 줄에서 chaser_1은 다음 노드로 이동합니다. 이렇게 chaser_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.</p>\n<p>만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser_2의 다음 노드였던 chaser_1의 노드를 없애주기 위해 chaser_1 다음의 노드와 chaser_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.</p>\n<p>dequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">public class Main {\n\n    public static void main(String[] args) {\n        LinkedList animals = new LinkedList();\n\n        animals.enqueue(\"귀욤\",1);\n        animals.enqueue(\"개똥\",0);\n        animals.enqueue(\"황묘\",1);\n        animals.enqueue(\"백구\",0);\n\n        System.out.println(animals);\n\n        animals.dequeueDog();\n\n        System.out.println(animals);\n    }\n\n}\n</pre>\n\n<p>예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.</p>\n<p><img src=\"/images/aniqueue-result.jpg\" alt=\"\"></p>\n<p>전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.</p>\n"},{"id":"472","title":"[Practice] min연산을 갖춘 stack을 구현하라!","date":"2016-03-26T10:29:50.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=472","_content":"<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 &#8211; 연습문제 3.2**\n\n**&#8220;push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.&#8221;**\n\n이 문제의 포인트는 &#8216;min연산&#8217;, &#8216;O(1)&#8217;에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. &#8216;그냥 stack을 하나 더 만들면 안돼?&#8217;라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 &#8216;옳다쿠나&#8217; 정답이었습니다.\n\n구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n\n</pre>\n\n우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top &gt;= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n</pre>\n\n다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser\\_push는 인자로 num값을 받습니다. 만약에 chaser\\_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.\n  \n이어사 등장하는 chaser\\_pop도 일반적인 pop과 같습니다. 우선 chaser\\_top을 감소시켜줍니다. 그리고 min\\_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur\\_min값을 바꿔줍니다.\n\n_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 &#8220;I am number 5. I was a min number!&#8221; 같은 메세지가 나왔습니다.</span>_\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//main_stack push function\nvoid push(int num) {\n   if(main_top &gt;= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num &lt; cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n      \n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n</pre>\n\n기본적인 push&pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main\\_stack에 처음으로 push를 하는 경우가 나옵니다. main\\_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur\\_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur\\_num값과 비교해서 더 작은 경우에만 chaser\\_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur\\_num가 같을 경우, main\\_stack의 pop이 아니라 chaser\\_pop으로 넘어갑니다. 거기서 &#8220;I was a min number!&#8221;라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.\n\n이제 테스트해보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">int main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n</pre>\n\n결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)\n![](/images/practice-1-result.png)\n\n&nbsp;  \n\n[Practice 1] &#8220;min연산을 갖춘 stack을 구현하라!&#8221; 끝.\n\n질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요. ^^","source":"_posts/practice-min-stack.md","raw":"---\nid: 472\ntitle: '[Practice] min연산을 갖춘 stack을 구현하라!'\ndate: 2016-03-26T19:29:50+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=472\npermalink: /practice-1/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - practice\n---\n<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 &#8211; 연습문제 3.2**\n\n**&#8220;push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.&#8221;**\n\n이 문제의 포인트는 &#8216;min연산&#8217;, &#8216;O(1)&#8217;에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. &#8216;그냥 stack을 하나 더 만들면 안돼?&#8217;라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 &#8216;옳다쿠나&#8217; 정답이었습니다.\n\n구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n\n</pre>\n\n우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top &gt;= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n</pre>\n\n다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser\\_push는 인자로 num값을 받습니다. 만약에 chaser\\_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.\n  \n이어사 등장하는 chaser\\_pop도 일반적인 pop과 같습니다. 우선 chaser\\_top을 감소시켜줍니다. 그리고 min\\_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur\\_min값을 바꿔줍니다.\n\n_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 &#8220;I am number 5. I was a min number!&#8221; 같은 메세지가 나왔습니다.</span>_\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//main_stack push function\nvoid push(int num) {\n   if(main_top &gt;= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num &lt; cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n      \n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n</pre>\n\n기본적인 push&pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main\\_stack에 처음으로 push를 하는 경우가 나옵니다. main\\_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur\\_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur\\_num값과 비교해서 더 작은 경우에만 chaser\\_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur\\_num가 같을 경우, main\\_stack의 pop이 아니라 chaser\\_pop으로 넘어갑니다. 거기서 &#8220;I was a min number!&#8221;라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.\n\n이제 테스트해보겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">int main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n</pre>\n\n결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)\n![](/images/practice-1-result.png)\n\n&nbsp;  \n\n[Practice 1] &#8220;min연산을 갖춘 stack을 구현하라!&#8221; 끝.\n\n질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요. ^^","slug":"/practice-1/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1sf002ei3vg1krirt8c","content":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 &#8211; 연습문제 3.2</strong></p>\n<p><strong>&#8220;push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.&#8221;</strong></p>\n<p>이 문제의 포인트는 &#8216;min연산&#8217;, &#8216;O(1)&#8217;에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. &#8216;그냥 stack을 하나 더 만들면 안돼?&#8217;라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 &#8216;옳다쿠나&#8217; 정답이었습니다.</p>\n<p>구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n\n</pre>\n\n<p>우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top &gt;= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n</pre>\n\n<p>다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser_push는 인자로 num값을 받습니다. 만약에 chaser_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.</p>\n<p>이어사 등장하는 chaser_pop도 일반적인 pop과 같습니다. 우선 chaser_top을 감소시켜줍니다. 그리고 min_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur_min값을 바꿔줍니다.</p>\n<p><em><span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 &#8220;I am number 5. I was a min number!&#8221; 같은 메세지가 나왔습니다.</span></em></p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//main_stack push function\nvoid push(int num) {\n   if(main_top &gt;= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num &lt; cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n\n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n</pre>\n\n<p>기본적인 push&amp;pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main_stack에 처음으로 push를 하는 경우가 나옵니다. main_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur_num값과 비교해서 더 작은 경우에만 chaser_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur_num가 같을 경우, main_stack의 pop이 아니라 chaser_pop으로 넘어갑니다. 거기서 &#8220;I was a min number!&#8221;라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.</p>\n<p>이제 테스트해보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">int main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n</pre>\n\n<p>결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)<br><img src=\"/images/practice-1-result.png\" alt=\"\"></p>\n<p>&nbsp;  </p>\n<p>[Practice 1] &#8220;min연산을 갖춘 stack을 구현하라!&#8221; 끝.</p>\n<p>질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요. ^^</p>\n","excerpt":"","more":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 &#8211; 연습문제 3.2</strong></p>\n<p><strong>&#8220;push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.&#8221;</strong></p>\n<p>이 문제의 포인트는 &#8216;min연산&#8217;, &#8216;O(1)&#8217;에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. &#8216;그냥 stack을 하나 더 만들면 안돼?&#8217;라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 &#8216;옳다쿠나&#8217; 정답이었습니다.</p>\n<p>구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">#include &lt;stdio.h&gt;\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n\n</pre>\n\n<p>우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top &gt;= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n</pre>\n\n<p>다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser_push는 인자로 num값을 받습니다. 만약에 chaser_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.</p>\n<p>이어사 등장하는 chaser_pop도 일반적인 pop과 같습니다. 우선 chaser_top을 감소시켜줍니다. 그리고 min_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur_min값을 바꿔줍니다.</p>\n<p><em><span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 &#8220;I am number 5. I was a min number!&#8221; 같은 메세지가 나왔습니다.</span></em></p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">//main_stack push function\nvoid push(int num) {\n   if(main_top &gt;= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num &lt; cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n\n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n</pre>\n\n<p>기본적인 push&amp;pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main_stack에 처음으로 push를 하는 경우가 나옵니다. main_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur_num값과 비교해서 더 작은 경우에만 chaser_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur_num가 같을 경우, main_stack의 pop이 아니라 chaser_pop으로 넘어갑니다. 거기서 &#8220;I was a min number!&#8221;라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.</p>\n<p>이제 테스트해보겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">int main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n</pre>\n\n<p>결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)<br><img src=\"/images/practice-1-result.png\" alt=\"\"></p>\n<p>&nbsp;  </p>\n<p>[Practice 1] &#8220;min연산을 갖춘 stack을 구현하라!&#8221; 끝.</p>\n<p>질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요. ^^</p>\n"},{"id":"516","title":"PRATO 개발기 (1)","date":"2016-04-28T06:14:17.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=516","_content":"### 소개\n\nPRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.\n\n해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.\n\n주요 기능은 &#8216;**악보 검색**&#8216;, &#8216;**콘티 편집**&#8216;, &#8216;**콘티 출력**&#8216; 입니다.\n\n개발 과정 및 코드는 [Github](https://github.com/joeunha/praisetogether)을 통해 확인하실 수 있습니다.\n\n&nbsp;\n\n### 개발 환경 만들기\n\n그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 [Yeoman](http://yeoman.io/)을 이용했습니다.\n\n개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.\n\nnode (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.\n\n다음 시간에는 페이지 구조를 잡아보겠습니다.","source":"_posts/prato-1.md","raw":"---\nid: 516\ntitle: PRATO 개발기 (1)\ndate: 2016-04-28T15:14:17+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=516\npermalink: /prato-1/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - toy-project\n---\n### 소개\n\nPRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.\n\n해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.\n\n주요 기능은 &#8216;**악보 검색**&#8216;, &#8216;**콘티 편집**&#8216;, &#8216;**콘티 출력**&#8216; 입니다.\n\n개발 과정 및 코드는 [Github](https://github.com/joeunha/praisetogether)을 통해 확인하실 수 있습니다.\n\n&nbsp;\n\n### 개발 환경 만들기\n\n그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 [Yeoman](http://yeoman.io/)을 이용했습니다.\n\n개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.\n\nnode (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.\n\n다음 시간에는 페이지 구조를 잡아보겠습니다.","slug":"/prato-1/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1sl002ii3vgetlyl73t","content":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>PRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.</p>\n<p>해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.</p>\n<p>주요 기능은 &#8216;<strong>악보 검색</strong>&#8216;, &#8216;<strong>콘티 편집</strong>&#8216;, &#8216;<strong>콘티 출력</strong>&#8216; 입니다.</p>\n<p>개발 과정 및 코드는 <a href=\"https://github.com/joeunha/praisetogether\" target=\"_blank\" rel=\"external\">Github</a>을 통해 확인하실 수 있습니다.</p>\n<p>&nbsp;</p>\n<h3 id=\"개발-환경-만들기\"><a href=\"#개발-환경-만들기\" class=\"headerlink\" title=\"개발 환경 만들기\"></a>개발 환경 만들기</h3><p>그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 <a href=\"http://yeoman.io/\" target=\"_blank\" rel=\"external\">Yeoman</a>을 이용했습니다.</p>\n<p>개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.</p>\n<p>node (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.</p>\n<p>다음 시간에는 페이지 구조를 잡아보겠습니다.</p>\n","excerpt":"","more":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>PRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.</p>\n<p>해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.</p>\n<p>주요 기능은 &#8216;<strong>악보 검색</strong>&#8216;, &#8216;<strong>콘티 편집</strong>&#8216;, &#8216;<strong>콘티 출력</strong>&#8216; 입니다.</p>\n<p>개발 과정 및 코드는 <a href=\"https://github.com/joeunha/praisetogether\">Github</a>을 통해 확인하실 수 있습니다.</p>\n<p>&nbsp;</p>\n<h3 id=\"개발-환경-만들기\"><a href=\"#개발-환경-만들기\" class=\"headerlink\" title=\"개발 환경 만들기\"></a>개발 환경 만들기</h3><p>그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 <a href=\"http://yeoman.io/\">Yeoman</a>을 이용했습니다.</p>\n<p>개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.</p>\n<p>node (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.</p>\n<p>다음 시간에는 페이지 구조를 잡아보겠습니다.</p>\n"},{"id":"518","title":"PRATO 개발기 (2)","date":"2016-05-23T00:05:29.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=518","_content":"페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 [페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 ](https://ovenapp.io/) 를 활용했습니다.\n\n분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.\n\n* * *\n\n(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 [이곳](http://codepen.io/rabbylab/full/jrWKPR/)에서 보실 수 있습니다.","source":"_posts/prato-2.md","raw":"---\nid: 518\ntitle: PRATO 개발기 (2)\ndate: 2016-05-23T09:05:29+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=518\npermalink: /prato-2/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - toy-project\n---\n페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 [페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 ](https://ovenapp.io/) 를 활용했습니다.\n\n분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.\n\n* * *\n\n(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 [이곳](http://codepen.io/rabbylab/full/jrWKPR/)에서 보실 수 있습니다.","slug":"/prato-2/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1sp002li3vgqgs52ai0","content":"<p>페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"external\">이곳</a>에서 보실 수 있습니다. 도구는 <a href=\"https://ovenapp.io/\" target=\"_blank\" rel=\"external\">페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"external\">이곳</a>에서 보실 수 있습니다. 도구는 </a> 를 활용했습니다.</p>\n<p>분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.</p>\n<hr>\n<p>(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 <a href=\"http://codepen.io/rabbylab/full/jrWKPR/\" target=\"_blank\" rel=\"external\">이곳</a>에서 보실 수 있습니다.</p>\n","excerpt":"","more":"<p>페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\">이곳</a>에서 보실 수 있습니다. 도구는 <a href=\"https://ovenapp.io/\">페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\">이곳</a>에서 보실 수 있습니다. 도구는 </a> 를 활용했습니다.</p>\n<p>분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.</p>\n<hr>\n<p>(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 <a href=\"http://codepen.io/rabbylab/full/jrWKPR/\">이곳</a>에서 보실 수 있습니다.</p>\n"},{"id":"540","title":"[Challenge] Tribute Page 만들기","date":"2016-05-26T08:51:04.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=540","_content":"[FreeCodeCamp](https://www.freecodecamp.com/)를 시작한지 3주가 되어갑니다. 지금까지 [13시간 분량의 공부를 진행했네요.](https://www.freecodecamp.com/joeunha) Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)\n\n첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. [예시](https://codepen.io/FreeCodeCamp/full/NNvBQW/)를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.\n\n과제를 위해 [CodePen](https://codepen.io/)이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.\n\n저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. [이곳](https://codepen.io/rabbylab/pen/mEbVNJ)에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)\n\n다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.","source":"_posts/project-tribute-page.md","raw":"---\nid: 540\ntitle: '[Challenge] Tribute Page 만들기'\ndate: 2016-05-26T17:51:04+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=540\npermalink: /project-tribute-page/\ncategories:\n  - rabbylab(wordpress)\ntags:\n  - freecodecamp\n---\n[FreeCodeCamp](https://www.freecodecamp.com/)를 시작한지 3주가 되어갑니다. 지금까지 [13시간 분량의 공부를 진행했네요.](https://www.freecodecamp.com/joeunha) Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)\n\n첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. [예시](https://codepen.io/FreeCodeCamp/full/NNvBQW/)를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.\n\n과제를 위해 [CodePen](https://codepen.io/)이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.\n\n저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. [이곳](https://codepen.io/rabbylab/pen/mEbVNJ)에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)\n\n다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.","slug":"/project-tribute-page/","published":1,"updated":"2017-04-21T15:19:34.000Z","comments":1,"photos":[],"link":"","_id":"cj33ux1t2002pi3vgqxsa91o9","content":"<p><a href=\"https://www.freecodecamp.com/\" target=\"_blank\" rel=\"external\">FreeCodeCamp</a>를 시작한지 3주가 되어갑니다. 지금까지 <a href=\"https://www.freecodecamp.com/joeunha\" target=\"_blank\" rel=\"external\">13시간 분량의 공부를 진행했네요.</a> Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)</p>\n<p>첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. <a href=\"https://codepen.io/FreeCodeCamp/full/NNvBQW/\" target=\"_blank\" rel=\"external\">예시</a>를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.</p>\n<p>과제를 위해 <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"external\">CodePen</a>이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.</p>\n<p>저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. <a href=\"https://codepen.io/rabbylab/pen/mEbVNJ\" target=\"_blank\" rel=\"external\">이곳</a>에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)</p>\n<p>다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.</p>\n","excerpt":"","more":"<p><a href=\"https://www.freecodecamp.com/\">FreeCodeCamp</a>를 시작한지 3주가 되어갑니다. 지금까지 <a href=\"https://www.freecodecamp.com/joeunha\">13시간 분량의 공부를 진행했네요.</a> Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)</p>\n<p>첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. <a href=\"https://codepen.io/FreeCodeCamp/full/NNvBQW/\">예시</a>를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.</p>\n<p>과제를 위해 <a href=\"https://codepen.io/\">CodePen</a>이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.</p>\n<p>저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. <a href=\"https://codepen.io/rabbylab/pen/mEbVNJ\">이곳</a>에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)</p>\n<p>다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj33ux1nz0009i3vgfyfujq1f","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1o7000di3vga2gi6qlp"},{"post_id":"cj33ux1ms0001i3vgixhw5drm","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1oa000hi3vg82fs2r3h"},{"post_id":"cj33ux1n20004i3vgt61cpqvh","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1od000ji3vgrg9mjdyu"},{"post_id":"cj33ux1n40005i3vgo20w2hqj","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1oi000ni3vgfi1lid1x"},{"post_id":"cj33ux1mn0000i3vgqy5pz9k2","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1oq000ri3vgo0giqm76"},{"post_id":"cj33ux1mn0000i3vgqy5pz9k2","category_id":"cj33ux1od000ki3vgib5fig69","_id":"cj33ux1or000ti3vgdycynggr"},{"post_id":"cj33ux1nl0006i3vg9d23oc28","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1or000vi3vgc92h0fhx"},{"post_id":"cj33ux1pk000xi3vgva65fbay","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1q80012i3vgos3pcx62"},{"post_id":"cj33ux1q50011i3vg15q45mna","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1qi0017i3vgg0k5c35z"},{"post_id":"cj33ux1qe0015i3vgdeusrqvg","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1r4001ei3vgwdmgsmxd"},{"post_id":"cj33ux1qe0015i3vgdeusrqvg","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1r6001gi3vgzil1biu5"},{"post_id":"cj33ux1pu000zi3vg7y45t3ce","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1rb001ki3vghmyhmv57"},{"post_id":"cj33ux1pu000zi3vg7y45t3ce","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1rf001ni3vgmyld0s2e"},{"post_id":"cj33ux1qj0019i3vgay9bdgkr","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1rk001ri3vg3vch0zyb"},{"post_id":"cj33ux1qj0019i3vgay9bdgkr","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1rq001ui3vg81ngj6oa"},{"post_id":"cj33ux1qv001bi3vgc72zbz2w","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1rw001yi3vg35aqhe4x"},{"post_id":"cj33ux1qv001bi3vgc72zbz2w","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1s10021i3vgg7btgh5j"},{"post_id":"cj33ux1q90013i3vgfnr6v9ak","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1s30025i3vgok9oh61n"},{"post_id":"cj33ux1q90013i3vgfnr6v9ak","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1s60028i3vghv79x524"},{"post_id":"cj33ux1r2001di3vgaeywszws","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1sd002ci3vgtvt983yy"},{"post_id":"cj33ux1r2001di3vgaeywszws","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1si002fi3vgadn6fhaa"},{"post_id":"cj33ux1r5001fi3vgunfh1n2v","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1sn002ji3vgnpg7q3s7"},{"post_id":"cj33ux1r5001fi3vgunfh1n2v","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1st002mi3vg4wir1ktc"},{"post_id":"cj33ux1r9001ji3vgu27uvibu","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1t5002qi3vg8ewme1z7"},{"post_id":"cj33ux1r9001ji3vgu27uvibu","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1t8002si3vgztos3jiq"},{"post_id":"cj33ux1rd001mi3vgfba7jvcl","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1tf002vi3vg4iaj404u"},{"post_id":"cj33ux1rd001mi3vgfba7jvcl","category_id":"cj33ux1qa0014i3vgzagbx7wv","_id":"cj33ux1tk002xi3vgncb43yn4"},{"post_id":"cj33ux1ri001qi3vgam2sjyfk","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1tm002zi3vgtj71ojzb"},{"post_id":"cj33ux1ro001ti3vggv325b8h","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1tp0032i3vg90gns3fi"},{"post_id":"cj33ux1rs001xi3vgj939idha","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1tu0034i3vgyn02qz9j"},{"post_id":"cj33ux1rz0020i3vg0twwiism","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1tv0037i3vgyjlu7cum"},{"post_id":"cj33ux1s20024i3vg1noqekrp","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1tx0039i3vgkzu71tf3"},{"post_id":"cj33ux1s50027i3vg28ms48qj","category_id":"cj33ux1mx0002i3vgpa3xhugj","_id":"cj33ux1u1003ci3vgaebv3bt9"},{"post_id":"cj33ux1s50027i3vg28ms48qj","category_id":"cj33ux1od000ki3vgib5fig69","_id":"cj33ux1u3003ei3vg1cvqpb95"},{"post_id":"cj33ux1sa002bi3vgodto00h0","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1ub003gi3vgwg3vbxzf"},{"post_id":"cj33ux1sf002ei3vg1krirt8c","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1us003ii3vg8hvg8jc1"},{"post_id":"cj33ux1sl002ii3vgetlyl73t","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1ut003ki3vg87t34egd"},{"post_id":"cj33ux1sp002li3vgqgs52ai0","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1ut003mi3vg72rnk0n7"},{"post_id":"cj33ux1t2002pi3vgqxsa91o9","category_id":"cj33ux1nu0007i3vgdke4ytjv","_id":"cj33ux1uw003oi3vgt76ky49g"}],"PostTag":[{"post_id":"cj33ux1mn0000i3vgqy5pz9k2","tag_id":"cj33ux1n10003i3vgstqhz919","_id":"cj33ux1o5000ci3vgiaers14f"},{"post_id":"cj33ux1mn0000i3vgqy5pz9k2","tag_id":"cj33ux1nv0008i3vg37q2xubc","_id":"cj33ux1o7000ei3vgflooth6h"},{"post_id":"cj33ux1ms0001i3vgixhw5drm","tag_id":"cj33ux1o3000bi3vgvvgc04vy","_id":"cj33ux1oc000ii3vg7b6ypz4m"},{"post_id":"cj33ux1n20004i3vgt61cpqvh","tag_id":"cj33ux1o9000gi3vgannwo76t","_id":"cj33ux1oi000mi3vg5ooaq0jz"},{"post_id":"cj33ux1n40005i3vgo20w2hqj","tag_id":"cj33ux1o9000gi3vgannwo76t","_id":"cj33ux1on000qi3vgd8g33852"},{"post_id":"cj33ux1nl0006i3vg9d23oc28","tag_id":"cj33ux1ol000pi3vgaprsxsnv","_id":"cj33ux1or000ui3vghtz5wbzq"},{"post_id":"cj33ux1nz0009i3vgfyfujq1f","tag_id":"cj33ux1oq000si3vglvw1hce5","_id":"cj33ux1or000wi3vg3page1ev"},{"post_id":"cj33ux1pk000xi3vgva65fbay","tag_id":"cj33ux1q40010i3vgpog96hc0","_id":"cj33ux1qi0018i3vg7f2dz9yq"},{"post_id":"cj33ux1r2001di3vgaeywszws","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1r9001ii3vg5sgcn3xj"},{"post_id":"cj33ux1r2001di3vgaeywszws","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1rd001li3vgn7empno7"},{"post_id":"cj33ux1pu000zi3vg7y45t3ce","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1rh001oi3vgvi1salb1"},{"post_id":"cj33ux1pu000zi3vg7y45t3ce","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1rn001si3vguo054y0v"},{"post_id":"cj33ux1r5001fi3vgunfh1n2v","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1rr001vi3vg3h3649aq"},{"post_id":"cj33ux1r5001fi3vgunfh1n2v","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1rz001zi3vgjbqg55j5"},{"post_id":"cj33ux1r9001ji3vgu27uvibu","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1s10022i3vgql4q0izi"},{"post_id":"cj33ux1r9001ji3vgu27uvibu","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1s40026i3vg1kvak731"},{"post_id":"cj33ux1q50011i3vg15q45mna","tag_id":"cj33ux1r8001hi3vg2c6i5f15","_id":"cj33ux1s90029i3vglhyni5fe"},{"post_id":"cj33ux1rd001mi3vgfba7jvcl","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1se002di3vgpdjfqs9r"},{"post_id":"cj33ux1rd001mi3vgfba7jvcl","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1sk002gi3vgiytz6v4d"},{"post_id":"cj33ux1ri001qi3vgam2sjyfk","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1so002ki3vgjdv4nsct"},{"post_id":"cj33ux1ro001ti3vggv325b8h","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1sw002ni3vgczkdp0e4"},{"post_id":"cj33ux1rs001xi3vgj939idha","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1t7002ri3vghvns91oe"},{"post_id":"cj33ux1q90013i3vgfnr6v9ak","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1td002ti3vg6fcmojeb"},{"post_id":"cj33ux1q90013i3vgfnr6v9ak","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1tk002wi3vgcjqfbzhr"},{"post_id":"cj33ux1rz0020i3vg0twwiism","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1tl002yi3vg8evjk1vt"},{"post_id":"cj33ux1s20024i3vg1noqekrp","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1to0031i3vge0i1ji8w"},{"post_id":"cj33ux1s50027i3vg28ms48qj","tag_id":"cj33ux1n10003i3vgstqhz919","_id":"cj33ux1tq0033i3vgc0d7dr5m"},{"post_id":"cj33ux1s50027i3vg28ms48qj","tag_id":"cj33ux1nv0008i3vg37q2xubc","_id":"cj33ux1tv0036i3vgfs4era63"},{"post_id":"cj33ux1qe0015i3vgdeusrqvg","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1tx0038i3vgaijgx58j"},{"post_id":"cj33ux1qe0015i3vgdeusrqvg","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1u0003bi3vgprexym89"},{"post_id":"cj33ux1qj0019i3vgay9bdgkr","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1u1003di3vga3wrb4hk"},{"post_id":"cj33ux1qj0019i3vgay9bdgkr","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1ua003fi3vgl0cz236i"},{"post_id":"cj33ux1t2002pi3vgqxsa91o9","tag_id":"cj33ux1o3000bi3vgvvgc04vy","_id":"cj33ux1ur003hi3vg696j3mhl"},{"post_id":"cj33ux1qv001bi3vgc72zbz2w","tag_id":"cj33ux1qh0016i3vg0kguifi0","_id":"cj33ux1us003ji3vgqlywzgdt"},{"post_id":"cj33ux1qv001bi3vgc72zbz2w","tag_id":"cj33ux1qy001ci3vgolpqx4l1","_id":"cj33ux1ut003li3vgcjb6cer5"},{"post_id":"cj33ux1sa002bi3vgodto00h0","tag_id":"cj33ux1te002ui3vggwqn54q4","_id":"cj33ux1uv003ni3vg8mmi5u79"},{"post_id":"cj33ux1sf002ei3vg1krirt8c","tag_id":"cj33ux1te002ui3vggwqn54q4","_id":"cj33ux1ux003pi3vgwn4eqxhj"},{"post_id":"cj33ux1sl002ii3vgetlyl73t","tag_id":"cj33ux1tu0035i3vgg9vw50uc","_id":"cj33ux1uy003qi3vgxy69w89w"},{"post_id":"cj33ux1sp002li3vgqgs52ai0","tag_id":"cj33ux1tu0035i3vgg9vw50uc","_id":"cj33ux1uz003ri3vg85v34nj1"}],"Tag":[{"name":"opinion","_id":"cj33ux1n10003i3vgstqhz919"},{"name":"나와같다면","_id":"cj33ux1nv0008i3vg37q2xubc"},{"name":"freecodecamp","_id":"cj33ux1o3000bi3vgvvgc04vy"},{"name":"css","_id":"cj33ux1o9000gi3vgannwo76t"},{"name":"coin","_id":"cj33ux1ol000pi3vgaprsxsnv"},{"name":"daily-commit","_id":"cj33ux1oq000si3vglvw1hce5"},{"name":"cs-basic","_id":"cj33ux1q40010i3vgpog96hc0"},{"name":"javascript","_id":"cj33ux1qh0016i3vg0kguifi0"},{"name":"오늘의함수","_id":"cj33ux1qy001ci3vgolpqx4l1"},{"name":"introduction","_id":"cj33ux1r8001hi3vg2c6i5f15"},{"name":"practice","_id":"cj33ux1te002ui3vggwqn54q4"},{"name":"toy-project","_id":"cj33ux1tu0035i3vgg9vw50uc"}]}}